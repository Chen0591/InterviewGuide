(window.webpackJsonp=window.webpackJsonp||[]).push([[393],{810:function(t,n,e){"use strict";e.r(n);var s=e(62),r=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",{attrs:{id:"快乐数"}}),t._v(" "),e("h3",{attrs:{id:"_202-快乐数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_202-快乐数"}},[t._v("#")]),t._v(" 202. 快乐数")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/happy-number/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("编写一个算法来判断一个数是不是“快乐数”。")]),t._v(" "),e("p",[t._v("一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。")]),t._v(" "),e("p",[e("strong",[t._v("示例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: 19\n输出: true\n解释: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n")])])]),e("h4",{attrs:{id:"第一版-其实不算难-试试几个样例就知道了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-其实不算难-试试几个样例就知道了"}},[t._v("#")]),t._v(" 第一版，其实不算难，试试几个样例就知道了")]),t._v(" "),e("p",[t._v("不是快乐数的会重复某些过程")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 cpp 提交中击败了78.57%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.6 MB, 在所有 cpp 提交中击败了7.97%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("bool isHappy(int n) {\n\n\tif (n <= 0) return false;\n\tunordered_set<int> res;\n\tint sum = 0;\n\twhile (n != 1) {\n\t\tsum = 0;\n\t\twhile (n > 9) {\n\t\t\tsum += (n % 10) * (n % 10);\n\t\t\tn = n / 10;\n\t\t}\n\t\tsum += n * n;\n\t\tif (res.find(sum) != res.end()) return false;\n\t\telse res.insert(sum);\n\t\tn = sum;\n\t}\n\n\treturn true;\n}\n\n")])])]),e("p",{attrs:{id:"计数质数"}}),t._v(" "),e("h3",{attrs:{id:"_204-计数质数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_204-计数质数"}},[t._v("#")]),t._v(" 204. 计数质数")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/count-primes/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("统计所有小于非负整数 "),e("em",[t._v("n")]),t._v(" 的质数的数量。")]),t._v(" "),e("p",[e("strong",[t._v("示例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: 10\n输出: 4\n解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n")])])]),e("h4",{attrs:{id:"第一版-暴力法-超时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-暴力法-超时"}},[t._v("#")]),t._v(" 第一版，暴力法，超时")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int isPrimes(int i) {\n\n\n\tfor (int j = 2; j * j <= i; ++j) {\n\t\tif (i % j == 0) return 0;\n\t}\n\n\treturn 1;\n\n\n}\nint countPrimes(int n) {\n\tif (n <= 2) return 0;\n\n\tint sum = 0;\n\tfor (int i = 2; i < n; ++i) {\n\t\tsum += isPrimes(i);\n\t}\n\n\treturn sum;\n\n}\n\n\n\n\n")])])]),e("h4",{attrs:{id:"第二版-比较牛逼的一种解法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-比较牛逼的一种解法"}},[t._v("#")]),t._v(" 第二版，比较牛逼的一种解法")]),t._v(" "),e("p",[t._v("执行用时 :40 ms, 在所有 cpp 提交中击败了91.18%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :21.6 MB, 在所有 cpp 提交中击败了5.23%的用户")]),t._v(" "),e("p",[t._v("这题搜到一个非常牛逼的算法,叫做厄拉多塞筛法. 比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,再把5所有的倍数划去.以此类推.")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int countPrimes(int n) {\n\tvector<int> a(n);\n\tint count = 0;\n\tfor (int i = 2; i < n; i++)\n\t\ta[i] = 1;\n\n\tfor (int i = 2; i < n; i++)\n\t\tif (a[i])\n\t\t{\n\t\t\tcount++;\n\t\t\tfor (int j = 2 * i; j < n; j += i)\n\t\t\t\ta[j] = 0;\n\t\t}\n\n\treturn count;\n\n}\n")])])]),e("p",{attrs:{id:"同构字符串"}}),t._v(" "),e("h3",{attrs:{id:"_205-同构字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_205-同构字符串"}},[t._v("#")]),t._v(" 205. 同构字符串")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/isomorphic-strings/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定两个字符串 s 和 t，判断它们是否是同构的。")]),t._v(" "),e("p",[t._v("如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。")]),t._v(" "),e("p",[t._v("所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。")]),t._v(" "),e("p",[t._v("示例 1:")]),t._v(" "),e("p",[t._v('输入: s = "egg", t = "add"\n输出: true\n示例 2:')]),t._v(" "),e("p",[t._v('输入: s = "foo", t = "bar"\n输出: false\n示例 3:')]),t._v(" "),e("p",[t._v('输入: s = "paper", t = "title"\n输出: true\n说明:\n你可以假设 s 和 t 具有相同的长度。')]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的-常见写法-比较慢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的-常见写法-比较慢"}},[t._v("#")]),t._v(" 第一版，自己写的，常见写法，比较慢")]),t._v(" "),e("p",[t._v("执行用时 :20 ms, 在所有 cpp 提交中击败了42.04%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :10.4 MB, 在所有 cpp 提交中击败了5.09%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("bool isIsomorphic(string s, string t) {\n\t//if (s.size() == 0) return true;\n\n\n\tunordered_map<char, char> un_mp1(s.size()), un_mp2(s.size());\n\tfor (unsigned i = 0; i < s.size();++i) {\n\t\tun_mp1[s[i]]= t[i];\n\t\tun_mp2[t[i]]= s[i];\n\t}\n\n\n\tfor (unsigned i = 0; i < s.size(); ++i) {\n\t\tif(un_mp1[s[i]]!=t[i]  || un_mp2[t[i]]!=s[i]) return false;\n\t}\n\n\treturn true;\n\n}\n")])])]),e("h4",{attrs:{id:"第二版-比较第一次出现的位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-比较第一次出现的位置"}},[t._v("#")]),t._v(" 第二版，比较第一次出现的位置")]),t._v(" "),e("p",[t._v("对比两个字符串对应位置的字符在字符串内第一次出现的位置")]),t._v(" "),e("p",[t._v("执行用时 :12 ms, 在所有 cpp 提交中击败了79.16%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :9.2 MB, 在所有 cpp 提交中击败了21.24%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    bool isIsomorphic(string s, string t) {\n        for(int i=0;i<s.size();i++){\n            if(s.find(s[i])!=t.find(t[i]))\n            return false;\n        }\n        return true;\n")])])]),e("h4",{attrs:{id:"第三版-另一种写法-同步进行相同字符位置的更替"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三版-另一种写法-同步进行相同字符位置的更替"}},[t._v("#")]),t._v(" 第三版 ，另一种写法，同步进行相同字符位置的更替")]),t._v(" "),e("p",[t._v("执行用时 :16 ms, 在所有 cpp 提交中击败了58.33%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :9.3 MB, 在所有 cpp 提交中击败了12.83%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("bool isIsomorphic(string s, string t) {\n\tunordered_map<char, int> un_mp1, un_mp2;\n\tfor (unsigned i = 0; i < s.size(); ++i) {\n\t\tun_mp1[s[i]] += 1+i;\n\t\tun_mp2[t[i]] += 1+i;\n\t\tif (un_mp1[s[i]] !=  un_mp2[t[i]] ) return false;\n\n\t}\n\treturn true;\n\n}\n\n")])])]),e("p",{attrs:{id:"单词规律"}}),t._v(" "),e("h3",{attrs:{id:"_290-单词规律"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_290-单词规律"}},[t._v("#")]),t._v(" 290. 单词规律")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/word-pattern/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。")]),t._v(" "),e("p",[t._v("这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。")]),t._v(" "),e("p",[t._v("示例1:")]),t._v(" "),e("p",[t._v('输入: pattern = "abba", str = "dog cat cat dog"\n输出: true\n示例 2:')]),t._v(" "),e("p",[t._v('输入:pattern = "abba", str = "dog cat cat fish"\n输出: false\n示例 3:')]),t._v(" "),e("p",[t._v('输入: pattern = "aaaa", str = "dog cat cat dog"\n输出: false\n示例 4:')]),t._v(" "),e("p",[t._v('输入: pattern = "abba", str = "dog dog dog dog"\n输出: false\n说明:\n你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。')]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的-参照以前的一个题目-经典的hash方法-非常好"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的-参照以前的一个题目-经典的hash方法-非常好"}},[t._v("#")]),t._v(" 第一版，自己写的，参照以前的一个题目,经典的hash方法，非常好")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 cpp 提交中击败了76.14%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.4 MB, 在所有 cpp 提交中击败了81.29%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('bool wordPattern(string pattern, string str) {\n\n\tunordered_map<char, int> patMp;\n\tunordered_map<string, int> strMp;\n\tstring temp = "";\n\tint a = 1;\n\tunsigned i, j;\n\tfor (i = 0, j = 0; i < pattern.size() && j < str.size(); ++j, ++i) {\n\t\ttemp = "";\n\t\tpatMp[pattern[i]] += i+a;\n\t\t//cout << "pat " << pattern[i] << " int " << patMp[pattern[i]] << endl;\n\t\twhile (str[j] != \' \' && j < str.size()) {\n\t\t\ttemp += str[j++];\n\t\t}\n\t\tstrMp[temp] += i+a;\n\t\t//cout << "str " << temp << " int " << strMp[temp] << endl;\n\n\t\tif (patMp[pattern[i]] != strMp[temp]) return false;\n}\n\t//cout << i <<" "<< j << endl;\n\treturn i==pattern.size()&&j==str.size()+1;\n}\n')])])]),e("p",{attrs:{id:"字符串中的第一个唯一字符"}}),t._v(" "),e("h3",{attrs:{id:"_387-字符串中的第一个唯一字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_387-字符串中的第一个唯一字符"}},[t._v("#")]),t._v(" 387. 字符串中的第一个唯一字符")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/first-unique-character-in-a-string/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。")]),t._v(" "),e("p",[e("strong",[t._v("案例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('s = "leetcode"\n返回 0.\n\ns = "loveleetcode",\n返回 2.\n')])])]),e("p",[t._v("**注意事项：**您可以假定该字符串只包含小写字母。")]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的-时间较慢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的-时间较慢"}},[t._v("#")]),t._v(" 第一版，自己写的，时间较慢")]),t._v(" "),e("p",[t._v("执行用时 :112 ms, 在所有 cpp 提交中击败了23.15%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :13 MB, 在所有 cpp 提交中击败了80.42%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('int firstUniqChar(string s) {\n\n\tif (s.size() == 0) return -1;\n\n\tunordered_map<char, pair<int, int>> result;//字符，出现次数，索引号\n\tfor (unsigned i = 0; i < s.size(); ++i) {\n\n\t\tresult[s[i]].first += 1;\n\t\tresult[s[i]].second += i;\n\n\t\t//if (result[s[i]].first >= 2) result.erase(s[i]);\n\t}\n\n\tint res = s.size()-1;\n\n\tbool isOnce= false;\n\tfor (auto& a : result) {\n\t\tif (a.second.first == 1)\n\t\t{\n\t\t\tres = res > a.second.second ? a.second.second : res;\n\t\t\tisOnce = true;\n\t\t}\n\t\t//cout << a.first << " " << a.second.first << " " << a.second.second << endl;\n\t}\n\n\tif (isOnce)\n\t\treturn res;\n\telse\n\t\treturn -1;\n\n}\n')])])]),e("h4",{attrs:{id:"第二版-看的别人的-快多了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-看的别人的-快多了"}},[t._v("#")]),t._v(" 第二版，看的别人的，快多了")]),t._v(" "),e("p",[t._v("执行用时 :32 ms, 在所有 cpp 提交中击败了91.92%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :12.6 MB, 在所有 cpp 提交中击败了96.83%的用户")]),t._v(" "),e("p",[e("strong",[t._v("就26个字符，所以直接开辟26个空间，初值都为0")])]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int firstUniqChar(string s) {\n\n\tint result[26] = { 0 };\n\tfor (auto &i : s)\n\t\tresult[i - 'a'] ++;//统计每个字母的出现次数，0就是‘a’,1就是‘b’\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (result[s[i] - 'a'] == 1)//找到第一个就可以\n\t\t\treturn i;\n\t}\n\treturn -1;\n\n}\n\n我的方法必须遍历所以的元素才能找出最小值，这个直接根据s中字母的出现的先后来看\n")])])]),e("h4",{attrs:{id:"第三版-看了第二版又改进的第一版-还是比较慢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三版-看了第二版又改进的第一版-还是比较慢"}},[t._v("#")]),t._v(" 第三版，看了第二版又改进的第一版,还是比较慢")]),t._v(" "),e("p",[t._v("执行用时 :84 ms, 在所有 cpp 提交中击败了39.24%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :13.2 MB, 在所有 cpp 提交中击败了70.44%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int firstUniqChar(string s) {\n\tunordered_map<char, pair<int, int>> result;//字符，出现次数，索引号\n\tfor (unsigned i = 0; i < s.size(); ++i) {\n\t\tresult[s[i]].first += 1;\n\t\tresult[s[i]].second += i;\n\t}\n\n\tfor (unsigned i = 0; i < s.size(); ++i) {\n\t\n\t\tif (result[s[i]].first == 1) \n\t\t\treturn result[s[i]].second;\n\t}\n\treturn -1;\n\n}\n")])])]),e("p",{attrs:{id:"最长和谐子序列"}}),t._v(" "),e("h3",{attrs:{id:"_594-最长和谐子序列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_594-最长和谐子序列"}},[t._v("#")]),t._v(" 594. 最长和谐子序列")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/longest-harmonious-subsequence/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。")]),t._v(" "),e("p",[t._v("现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: [1,3,2,2,5,2,3,7]\n输出: 5\n原因: 最长的和谐数组是：[3,2,2,2,3].\n")])])]),e("p",[e("strong",[t._v("说明:")]),t._v(" 输入的数组长度最大不超过20,000.")]),t._v(" "),e("h4",{attrs:{id:"第一版-犯糊涂了-要用有序的map才对-中规中矩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-犯糊涂了-要用有序的map才对-中规中矩"}},[t._v("#")]),t._v(" 第一版，犯糊涂了，要用有序的map才对，中规中矩")]),t._v(" "),e("p",[t._v("执行用时 :136 ms, 在所有 cpp 提交中击败了59.33%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :20.7 MB, 在所有 cpp 提交中击败了51.40%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('   int findLHS(vector<int>& nums) {\n\tif (nums.size() <= 1) return 0;\n\tsort(nums.begin(), nums.end(), greater<int>());\n\n\tmap<int, int> result;//元素，次数\n\tint maxLen = 0, temp,len=nums.size();\n\tfor (unsigned i = 0; i < len; ++i) {\n\t\tresult[nums[i]]++;\n\t}\n\n\n\tfor (auto beg = result.begin(), beg2 = ++result.begin(); beg2 != result.end() && beg != result.end();++beg,++beg2 ) {\n\t\t\n\t\tif (1+beg->first == beg2->first) {\n\n\t\t\ttemp = beg->second + beg2->second;\n\t\t\tmaxLen = temp > maxLen ? temp : maxLen;\n\t\t\t// cout << maxLen << endl;\n\t\t\t// cout << beg->first << " " << beg2->first << " " << temp << endl;\n\t\t}\n\t}\n\t// cout << maxLen << endl;\n\n\treturn maxLen;\n\n}\n')])])]),e("p",{attrs:{id:"两个列表的最小索引总和"}}),t._v(" "),e("h3",{attrs:{id:"_599-两个列表的最小索引总和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_599-两个列表的最小索引总和"}},[t._v("#")]),t._v(" 599. 两个列表的最小索引总和")]),t._v(" "),e("p",[t._v("假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。")]),t._v(" "),e("p",[t._v("你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。")]),t._v(" "),e("p",[t._v("示例 1:")]),t._v(" "),e("p",[t._v('输入:\n["Shogun", "Tapioca Express", "Burger King", "KFC"]\n["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]\n输出: ["Shogun"]\n解释: 他们唯一共同喜爱的餐厅是“Shogun”。\n示例 2:')]),t._v(" "),e("p",[t._v('输入:\n["Shogun", "Tapioca Express", "Burger King", "KFC"]\n["KFC", "Shogun", "Burger King"]\n输出: ["Shogun"]\n解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。\n提示:')]),t._v(" "),e("p",[t._v("两个列表的长度范围都在 [1, 1000]内。\n两个列表中的字符串的长度将在[1，30]的范围内。\n下标从0开始，到列表的长度减1。\n两个列表都没有重复的元素。")]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的-速度快-内存较大"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的-速度快-内存较大"}},[t._v("#")]),t._v(" 第一版，自己写的，速度快，内存较大")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, pair<int, int>> res;//餐厅名 索引号相加 ,出现次数\n\tint minIndex = INT_MAX;\n\t\n\tmultimap<int,string> result;\n\tfor (unsigned i = 0; i < list1.size(); ++i) {\n\t\tres[list1[i]] = { i,1 };\n\t}\n\n\tfor (unsigned i = 0; i < list2.size(); ++i) {\n\t\t\n\t\tres[list2[i]].first += i;\n\t\tres[list2[i]].second += 1;\n\t}\n\n\tfor (auto &a : res) {\n\n\t\tif (a.second.second == 2) {\t\n\t\t\tminIndex = a.second.first < minIndex ? a.second.first : minIndex;\n\t\t\tresult.insert({ a.second.first, a.first});\n\t\t}\n\t}\n\n\tmultimap<int, string>::iterator beg, end;\n\tbeg  = result.equal_range(minIndex).first;\n\tend = result.equal_range(minIndex).second;\n\n\n\n\tvector<string> r;\n\twhile (beg != end) {\n\t\tr.push_back(beg->second);\n\t\tbeg++;\n\t}\n\t\n\treturn r;\n        \n    }\n")])])]),e("h4",{attrs:{id:"第二版-换了一个写法-反而更差了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-换了一个写法-反而更差了"}},[t._v("#")]),t._v(" 第二版，换了一个写法，反而更差了...")]),t._v(" "),e("p",[t._v("执行用时 :188 ms, 在所有 cpp 提交中击败了40.00%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :32.3 MB, 在所有 cpp 提交中击败了14.21%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n\tunordered_map<string, pair<int, int>> res;//餐厅名 索引号相加 ,出现次数\n\tint minIndex;\n\tvector<string> result;\n\tfor (unsigned i = 0; i < list1.size(); ++i) {\n\t\tres[list1[i]] = { i,1 };\n\t}\n\n\tfor (unsigned i = 0; i < list2.size(); ++i) {\n\t\t\n\t\tres[list2[i]].first += i;\n\t\tres[list2[i]].second += 1;\n\t}\n\n\tfor (auto &a : res) {\n\t\tif (a.second.second == 2) {\t\n\n\t\t\tif (result.empty()) {//第一次为空直接进\n\t\t\t\tminIndex = a.second.first;\n\t\t\t\tresult.push_back(a.first);\n\t\t\t}\n\t\t\telse//不为空，与上一次最小值进行比较\n\t\t\t{\n\t\t\t\tif (a.second.first < minIndex) //当前最小值是最小的，进行更替\n\t\t\t\t{\n\t\t\t\t\tresult.clear();//清空结果\n\t\t\t\t\tminIndex = a.second.first;\n\t\t\t\t\tresult.push_back(a.first);\n\t\t\t\t}\n\t\t\t\telse if (a.second.first == minIndex)//和当前一样大，就直接进去\n\t\t\t\t{\n\t\t\t\t\tresult.push_back(a.first);\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\treturn result;\n    }\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\n")])])]),e("h4",{attrs:{id:"第三版-再换一个写法。。。还是第一版最快"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三版-再换一个写法。。。还是第一版最快"}},[t._v("#")]),t._v(" 第三版，再换一个写法。。。还是第一版最快")]),t._v(" "),e("p",[t._v("执行用时 :180 ms, 在所有 cpp 提交中击败了44.26%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :32.2 MB, 在所有 cpp 提交中击败了14.74%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n\tunordered_map<string, pair<int, int>> res;//餐厅名 索引号相加 ,出现次数\n\tint minIndex;\n\tvector<string> result;\n\tfor (unsigned i = 0; i < list1.size(); ++i) {\n\t\tres[list1[i]] = { i,1 };\n\t}\n\n\tfor (unsigned i = 0; i < list2.size(); ++i) {\n\t\t\n\t\tres[list2[i]].first += i;\n\t\tres[list2[i]].second += 1;\n\t\tif (res[list2[i]].second == 2)\n\t\t{\n\t\t\tif (result.empty()) {//第一次为空直接进\n\t\t\t\tminIndex = res[list2[i]].first;\n\t\t\t\tresult.push_back(list2[i]);\n\t\t\t}\n\t\t\telse//不为空，与上一次最小值进行比较\n\t\t\t{\n\t\t\t\tif (res[list2[i]].first < minIndex) //当前最小值是最小的，进行更替\n\t\t\t\t{\n\t\t\t\t\tresult.clear();//清空结果\n\t\t\t\t\tminIndex = res[list2[i]].first;\n\t\t\t\t\tresult.push_back(list2[i]);\n\t\t\t\t}\n\t\t\t\telse if (res[list2[i]].first == minIndex)//和当前一样大，就直接进去\n\t\t\t\t{\n\t\t\t\t\tresult.push_back(list2[i]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn result;\n}\n")])])]),e("p",{attrs:{id:"错误的集合"}}),t._v(" "),e("h3",{attrs:{id:"_645-错误的集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_645-错误的集合"}},[t._v("#")]),t._v(" 645. 错误的集合")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/set-mismatch/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("集合 "),e("code",[t._v("S")]),t._v(" 包含从1到 "),e("code",[t._v("n")]),t._v(" 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。")]),t._v(" "),e("p",[t._v("给定一个数组 "),e("code",[t._v("nums")]),t._v(" 代表了集合 "),e("code",[t._v("S")]),t._v(" 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: nums = [1,2,2,4]\n输出: [2,3]\n")])])]),e("p",[e("strong",[t._v("注意:")])]),t._v(" "),e("ol",[e("li",[t._v("给定数组的长度范围是 [2, 10000]。")]),t._v(" "),e("li",[t._v("给定的数组是无序的。")])]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的"}},[t._v("#")]),t._v(" 第一版，自己写的")]),t._v(" "),e("p",[t._v("执行用时 :68 ms, 在所有 cpp 提交中击败了32.82%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :20.6 MB, 在所有 cpp 提交中击败了18.10%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    vector<int> findErrorNums(vector<int>& nums) {\n    unordered_set<int> un_st;\n\tint len = nums.size(), sum,res;\n\tsum = (len + 1) * len / 2;\n\tfor (unsigned i = 0; i < len; ++i) {\n\n\t\tif (un_st.insert(nums[i]).second) {\n\t\t\tsum -= nums[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres = nums[i];\n\t\t}\n\t}\n\n\treturn { res,sum };\n       \n    }\n")])])]),e("p",{attrs:{id:"词典中最长的单词"}}),t._v(" "),e("h3",{attrs:{id:"_720-词典中最长的单词"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_720-词典中最长的单词"}},[t._v("#")]),t._v(" 720. 词典中最长的单词")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/longest-word-in-dictionary/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给出一个字符串数组"),e("code",[t._v("words")]),t._v("组成的一本英语词典。从中找出最长的一个单词，该单词是由"),e("code",[t._v("words")]),t._v("词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。")]),t._v(" "),e("p",[t._v("若无答案，则返回空字符串。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: \nwords = ["w","wo","wor","worl", "world"]\n输出: "world"\n解释: \n单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。\n')])])]),e("p",[e("strong",[t._v("示例 2:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: \nwords = ["a", "banana", "app", "appl", "ap", "apply", "apple"]\n输出: "apple"\n解释: \n"apply"和"apple"都能由词典中的单词组成。但是"apple"得字典序小于"apply"。\n')])])]),e("p",[e("strong",[t._v("注意:")])]),t._v(" "),e("ul",[e("li",[t._v("所有输入的字符串都只包含小写字母。")]),t._v(" "),e("li",[e("code",[t._v("words")]),t._v("数组长度范围为"),e("code",[t._v("[1,1000]")]),t._v("。")]),t._v(" "),e("li",[e("code",[t._v("words[i]")]),t._v("的长度范围为"),e("code",[t._v("[1,30]")]),t._v("。")])]),t._v(" "),e("h4",{attrs:{id:"第一版-看了提示-其实并没有什么窍门"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-看了提示-其实并没有什么窍门"}},[t._v("#")]),t._v(" 第一版，看了提示，其实并没有什么窍门")]),t._v(" "),e("p",[t._v("执行用时 :44 ms, 在所有 cpp 提交中击败了99.73%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :16.2 MB, 在所有 cpp 提交中击败了89.41%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("bool compareSize(const string& a, const string& b) {\n\n\tif(a.size()!=b.size())\n\t\treturn a.size() < b.size();\n\telse\n\t{\n\t\treturn a > b;//当size一样时，字典序小的在后面，这一点很厉害\n\t}\n}\n\nstring longestWord(vector<string>& words) {\n\n\tsort(words.begin(), words.end(), compareSize);\n\tunordered_set<string> unst;\n\tfor (auto& a : words) {\n\t\tunst.insert(a);\n\t}\n\n\tstring result;\n\tfor (int i=words.size()-1; i >=0;--i) {//从后往前走\n\n\t\tresult = words[i];\n\t\tint len = result.size();\n\t\twhile (len--) {\n\t\t\tresult.pop_back();\n\t\t\tif (unst.find(result) == unst.end()) break;\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tresult = words[i];\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n")])])]),e("p",{attrs:{id:"两句话中的不常见单词"}}),t._v(" "),e("h3",{attrs:{id:"_884-两句话中的不常见单词"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_884-两句话中的不常见单词"}},[t._v("#")]),t._v(" 884. 两句话中的不常见单词")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定两个句子 A 和 B 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）")]),t._v(" "),e("p",[t._v("如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。")]),t._v(" "),e("p",[t._v("返回所有不常用单词的列表。")]),t._v(" "),e("p",[t._v("您可以按任何顺序返回列表。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v('输入：A = "this apple is sweet", B = "this apple is sour"\n输出：["sweet","sour"]\n示例 2：')]),t._v(" "),e("p",[t._v('输入：A = "apple apple", B = "banana"\n输出：["banana"]')]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("0 <= A.length <= 200\n0 <= B.length <= 200\nA 和 B 都只包含空格和小写字母。")]),t._v(" "),e("h4",{attrs:{id:"第一版-很容易-自己写的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-很容易-自己写的"}},[t._v("#")]),t._v(" 第一版，很容易，自己写的")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 cpp 提交中击败了91.83%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.7 MB, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('vector<string> uncommonFromSentences(string A, string B) {\n\n\tunordered_map<string,int> un_mp;\n\n\tstring temp;\n\tfor (unsigned i=0;i<A.size();++i)\n\t{\n\t\ttemp = "";\n\t\twhile (A[i] != \' \' && i < A.size()) {\n\t\t\ttemp += A[i++];\n\t\t}\n\t\tif (temp.size() > 0) ++un_mp[temp];\n\t\t\n\t}\n\n\tfor (unsigned i = 0; i < B.size(); ++i)\n\t{\n\t\ttemp = "";\n\t\twhile (B[i] != \' \' && i < B.size()) {\n\t\t\ttemp += B[i++];\n\t\t}\n\t\tif (temp.size() > 0) ++un_mp[temp];\n\t}\n\n\tvector<string> res;\n\tfor (auto &a : un_mp) {\n\t\tif (a.second == 1) res.push_back(a.first);\n\t\t//cout << a.first << " " << a.second << endl;\n\t}\n\n\treturn res;\n\n}\n')])])]),e("p",{attrs:{id:"强整数"}}),t._v(" "),e("h3",{attrs:{id:"_970-强整数-看的答案-豁然开朗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_970-强整数-看的答案-豁然开朗"}},[t._v("#")]),t._v(" 970. 强整数   看的答案，豁然开朗")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/powerful-integers/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定两个正整数 "),e("code",[t._v("x")]),t._v(" 和 "),e("code",[t._v("y")]),t._v("，如果某一整数等于 "),e("code",[t._v("x^i + y^j")]),t._v("，其中整数 "),e("code",[t._v("i >= 0")]),t._v(" 且 "),e("code",[t._v("j >= 0")]),t._v("，那么我们认为该整数是一个"),e("em",[t._v("强整数")]),t._v("。")]),t._v(" "),e("p",[t._v("返回值小于或等于 "),e("code",[t._v("bound")]),t._v(" 的所有"),e("em",[t._v("强整数")]),t._v("组成的列表。")]),t._v(" "),e("p",[t._v("你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：x = 2, y = 3, bound = 10\n输出：[2,3,4,5,7,9,10]\n解释： \n2 = 2^0 + 3^0\n3 = 2^1 + 3^0\n4 = 2^0 + 3^1\n5 = 2^1 + 3^1\n7 = 2^2 + 3^1\n9 = 2^3 + 3^0\n10 = 2^0 + 3^2\n")])])]),e("p",[e("strong",[t._v("示例 2：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：x = 3, y = 5, bound = 15\n输出：[2,4,6,8,10,14]\n")])])]),e("p",[e("strong",[t._v("提示：")])]),t._v(" "),e("ul",[e("li",[e("code",[t._v("1 <= x <= 100")])]),t._v(" "),e("li",[e("code",[t._v("1 <= y <= 100")])]),t._v(" "),e("li",[e("code",[t._v("0 <= bound <= 10^6")])])]),t._v(" "),e("h4",{attrs:{id:"第一版-暴力法-加个上限20"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-暴力法-加个上限20"}},[t._v("#")]),t._v(" 第一版，暴力法，加个上限20")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 cpp 提交中击败了80.38%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.5 MB, 在所有 cpp 提交中击败了83.33%的用户")]),t._v(" "),e("p",[t._v("这里用unordered_set就可以了，不需要set，说了可以返回无顺序的")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    vector<int> powerfulIntegers(int x, int y, int bound) {\n    unordered_set<int> res;\n\tfor (int i = 0; i < 20 && pow(x, i) <= bound; i++) {\n\t\tfor (int j = 0; j < 20 && pow(y, j) <= bound; j++) {\n\t\t\tint v = int(pow(x, i)) + int(pow(y, j));\n\t\t\tif (v <= bound) res.insert(v);\n\t\t}\n\t}\n\tvector<int> res2;\n\tres2.assign(res.begin(), res.end());\n\treturn res2;\n        \n    }\n")])])]),e("p",{attrs:{id:"独一无二的出现次数"}}),t._v(" "),e("h3",{attrs:{id:"_1207-独一无二的出现次数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1207-独一无二的出现次数"}},[t._v("#")]),t._v(" 1207. 独一无二的出现次数")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/unique-number-of-occurrences/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。")]),t._v(" "),e("p",[t._v("如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v("输入：arr = [1,2,2,1,1,3]\n输出：true\n解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。\n示例 2：")]),t._v(" "),e("p",[t._v("输入：arr = [1,2]\n输出：false\n示例 3：")]),t._v(" "),e("p",[t._v("输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]\n输出：true")]),t._v(" "),e("h4",{attrs:{id:"第一版-unordered-map-unordered-set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-unordered-map-unordered-set"}},[t._v("#")]),t._v(" 第一版 unordered_map,unordered_set")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 cpp 提交中击败了88.78%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.9 MB, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\nbool uniqueOccurrences(vector<int>& arr) {\n\tunordered_map<int, int> un_mp(arr.size());\n\tunordered_set<int> un_st;\n\tfor (auto& a : arr) {\n\t\tun_mp[a]++;\n\t}\n\tfor (auto& a : un_mp) {\n\t\tun_st.insert(a.second);\t\n\t}\n\treturn un_st.size() == un_mp.size();\n\n\n}\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);