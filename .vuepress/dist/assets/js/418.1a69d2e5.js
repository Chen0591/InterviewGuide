(window.webpackJsonp=window.webpackJsonp||[]).push([[418],{838:function(t,n,e){"use strict";e.r(n);var s=e(62),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",{attrs:{id:"合并区间"}}),t._v(" "),e("h3",{attrs:{id:"_56-合并区间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_56-合并区间"}},[t._v("#")]),t._v(" 56. 合并区间")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/merge-intervals/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给出一个区间的集合，请合并所有重叠的区间。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n")])])]),e("p",[e("strong",[t._v("示例 2:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n")])])]),e("h4",{attrs:{id:"第一版-其实挺简单的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-其实挺简单的"}},[t._v("#")]),t._v(" 第一版，其实挺简单的")]),t._v(" "),e("p",[t._v("执行用时 :36 ms, 在所有 cpp 提交中击败了51.26%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :12.4 MB, 在所有 cpp 提交中击败了5.08%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<vector<int>> merge(vector<vector<int>>& intervals) {\n\n\tif (intervals.size() <= 1) return intervals;\n\n\tsort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {return a[0] < b[0]; });\n\tvector<vector<int>> ans{ intervals[0] };\n\tint n = intervals.size();\n\tfor (int i = 1; i < n; i++) {\n\t\tif (ans.back()[1] >= intervals[i][0]) {\n\t\t\tans.back()[1] = max(intervals[i][1], ans.back()[1]);\n\t\t\t//continue;\n\t\t}\n\t\telse {\n\t\t\tans.push_back(intervals[i]);\n\t\t\t//continue;\n\t\t}\n\t}\n\treturn ans;\n\n\n}\n")])])]),e("p",{attrs:{id:"颜色分类"}}),t._v(" "),e("h3",{attrs:{id:"_75-颜色分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_75-颜色分类"}},[t._v("#")]),t._v(" 75. 颜色分类")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/sort-colors/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个包含红色、白色和蓝色，一共 "),e("em",[t._v("n")]),t._v(" 个元素的数组，"),e("strong",[t._v("原地")]),t._v("对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。")]),t._v(" "),e("p",[t._v("此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。")]),t._v(" "),e("p",[e("strong",[t._v("注意:")]),t._v("\n不能使用代码库中的排序函数来解决这道题。")]),t._v(" "),e("p",[e("strong",[t._v("示例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n")])])]),e("p",[e("strong",[t._v("进阶：")])]),t._v(" "),e("ul",[e("li",[t._v("一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。")]),t._v(" "),e("li",[t._v("你能想出一个仅使用常数空间的一趟扫描算法吗？")])]),t._v(" "),e("h4",{attrs:{id:"第一版-直接解出来"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-直接解出来"}},[t._v("#")]),t._v(" 第一版，直接解出来")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 cpp 提交中击败了90.02%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.5 MB, 在所有 cpp 提交中击败了51.89%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("void sortColors(vector<int>& nums) {\n\tint zeroCut=0, oneCut=0, twoCut=0;\n\n\tfor (auto& n : nums) {\n\t\tif (n == 0) zeroCut++;\n\t\telse if (n == 1) oneCut++;\n\t\telse twoCut++;\n\t}\n\n\tfor (size_t i = 0; i < nums.size(); ++i) {\n\t\tif (i < zeroCut) nums[i] = 0;\n\t\telse if (i >= zeroCut && i < zeroCut + oneCut) nums[i] = 1;\n\t\telse\n\t\t\tnums[i] = 2;\n\n\t}\n\n\n}\n")])])]),e("h4",{attrs:{id:"第二版-进阶-双路快排的思想-感觉时间不太对"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-进阶-双路快排的思想-感觉时间不太对"}},[t._v("#")]),t._v(" 第二版，进阶，双路快排的思想，感觉时间不太对")]),t._v(" "),e("p",[t._v("执行用时 :0 ms, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.5 MB, 在所有 cpp 提交中击败了50.30%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    void sortColors(vector<int>& nums) {\n\tint low = 0, high = nums.size() - 1,index=-1;\n\twhile (low<=high)\n\t{\n\t\tif (nums[low] == 0) swap(nums[++index], nums[low++]);\n\t\telse if (nums[low] == 2) swap(nums[high--], nums[low]);\n\t\telse\n\t\t\tlow++;\n\t}\t\n        \n    }\n")])])]),e("p",{attrs:{id:"删除排序数组中的重复项"}}),t._v(" "),e("h3",{attrs:{id:"_80-删除排序数组中的重复项-ii-很好的题目"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_80-删除排序数组中的重复项-ii-很好的题目"}},[t._v("#")]),t._v(" 80. 删除排序数组中的重复项 II  很好的题目")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个排序数组，你需要在"),e("strong",[t._v("原地")]),t._v("删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。")]),t._v(" "),e("p",[t._v("不要使用额外的数组空间，你必须在"),e("strong",[t._v("原地修改输入数组")]),t._v("并在使用 O(1) 额外空间的条件下完成。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("给定 nums = [1,1,1,2,2,3],\n\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n")])])]),e("p",[e("strong",[t._v("示例 2:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("给定 nums = [0,0,1,1,1,1,2,3,3],\n\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n")])])]),e("p",[e("strong",[t._v("说明:")])]),t._v(" "),e("p",[t._v("为什么返回数值是整数，但输出的答案是数组呢?")]),t._v(" "),e("p",[t._v("请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。")]),t._v(" "),e("p",[t._v("你可以想象内部操作如下:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n")])])]),e("h4",{attrs:{id:"第一版-很简单粗暴-简单有效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-很简单粗暴-简单有效"}},[t._v("#")]),t._v(" 第一版，很简单粗暴,简单有效")]),t._v(" "),e("p",[t._v("执行用时 :12 ms, 在所有 cpp 提交中击败了98.85%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.9 MB, 在所有 cpp 提交中击败了73.46%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    int removeDuplicates(vector<int>& nums) {\n        int len = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (len < 2 || nums[i] != nums[len-2])\n                nums[len++] = nums[i];\n        }\n        return len;\n        \n    }\n")])])]),e("p",[t._v("，参考了评论区大佬的解法，在这里给解释一下各个步骤和变量的含义：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("len")]),t._v("表示的是删除重复元素后新序列的长度，同时也表示新元素进入新序列的索引；")]),t._v(" "),e("li",[e("code",[t._v("i")]),t._v("就是循环变量，用于遍历整个旧序列；")]),t._v(" "),e("li",[e("code",[t._v("if (len < 2) nums[len++] = nums[i];")]),t._v("的意思就是如果新序列的长度小于2（即新序列中不会存在两个相同的元素，这时候"),e("code",[t._v("i")]),t._v("位置所在元素不会和新序列中的元素相同），直接将新元素加入到新序列中，并更新新序列的长度；")]),t._v(" "),e("li",[e("code",[t._v("if (nums[i] != nums[len-2]) nums[len++] = nums[i];")]),t._v("的意思就是如果新元素加入后不会和前两个元素构成3个相同的元素（"),e("code",[t._v("nums[len-2]")]),t._v("就是直接取新序列中倒数第二个元素，如果该元素和新元素相同，说明加入后会构成3个相同的元素，显然是不符合题意的），就将新元素加入到新序列中，并更新新序列的长度；")]),t._v(" "),e("li",[t._v("题意只要求将新序列紧挨在一起就行，多出的长度将不参与评测；")])]),t._v(" "),e("p",{attrs:{id:"替换后的最长重复字符"}}),t._v(" "),e("h3",{attrs:{id:"_424-替换后的最长重复字符-心态崩了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_424-替换后的最长重复字符-心态崩了"}},[t._v("#")]),t._v(" 424. 替换后的最长重复字符 心态崩了")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/longest-repeating-character-replacement/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 "),e("em",[t._v("k")]),t._v(" 次。在执行上述操作后，找到包含重复字母的最长子串的长度。")]),t._v(" "),e("p",[e("strong",[t._v("注意:")]),t._v("\n字符串长度 和 "),e("em",[t._v("k")]),t._v(" 不会超过 10^4。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入:\ns = \"ABAB\", k = 2\n\n输出:\n4\n\n解释:\n用两个'A'替换为两个'B',反之亦然。\n")])])]),e("p",[e("strong",[t._v("示例 2:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入:\ns = "AABABBA", k = 1\n\n输出:\n4\n\n解释:\n将中间的一个\'A\'替换为\'B\',字符串变为 "AABBBBA"。\n子串 "BBBB" 有最长重复字母, 答案为 4。\n')])])]),e("p",{attrs:{id:"最大连续的个数"}}),t._v(" "),e("h3",{attrs:{id:"_485-最大连续1的个数-easy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_485-最大连续1的个数-easy"}},[t._v("#")]),t._v(" 485. 最大连续1的个数（easy）")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/max-consecutive-ones/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个二进制数组， 计算其中最大连续1的个数。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: [1,1,0,1,1,1]\n输出: 3\n解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.\n")])])]),e("p",[e("strong",[t._v("注意：")])]),t._v(" "),e("ul",[e("li",[t._v("输入的数组只包含 "),e("code",[t._v("0")]),t._v(" 和"),e("code",[t._v("1")]),t._v("。")]),t._v(" "),e("li",[t._v("输入数组的长度是正整数，且不超过 10,000。")])]),t._v(" "),e("h4",{attrs:{id:"第一版-很容易的题-果然还是被分类在容易类别中的题目啊"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-很容易的题-果然还是被分类在容易类别中的题目啊"}},[t._v("#")]),t._v(" 第一版，很容易的题...果然还是被分类在容易类别中的题目啊")]),t._v(" "),e("p",[t._v("执行用时 :32 ms, 在所有 cpp 提交中击败了97.20%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :11.7 MB, 在所有 cpp 提交中击败了71.52%的用户")]),t._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    int findMaxConsecutiveOnes(vector<int>& nums) {\n        \n    size_t result=0, cut = 0;\n\tfor (auto& num : nums) {\n\t\tif (num == 1) cut++;\n\t\telse {\n\t\t\tresult = max(result, cut);\n\t\t\tcut = 0;\n\t\t}\n\n\t}\n    result = max(result, cut);//这一步千万别忘了\n\treturn result;\n    }\n")])])]),e("p",{attrs:{id:"通过删除字母匹配到字典里最长单词"}}),t._v(" "),e("h3",{attrs:{id:"_524-通过删除字母匹配到字典里最长单词-心态崩了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_524-通过删除字母匹配到字典里最长单词-心态崩了"}},[t._v("#")]),t._v(" 524. 通过删除字母匹配到字典里最长单词 心态崩了")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入:\ns = "abpcplea", d = ["ale","apple","monkey","plea"]\n\n输出: \n"apple"\n')])])]),e("p",[e("strong",[t._v("示例 2:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入:\ns = "abpcplea", d = ["a","b","c"]\n\n输出: \n"a"\n')])])]),e("p",[e("strong",[t._v("说明:")])]),t._v(" "),e("ol",[e("li",[t._v("所有输入的字符串只包含小写字母。")]),t._v(" "),e("li",[t._v("字典的大小不会超过 1000。")]),t._v(" "),e("li",[t._v("所有输入的字符串长度不会超过 1000。")])]),t._v(" "),e("h4",{attrs:{id:"第一版-抄的抄的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-抄的抄的"}},[t._v("#")]),t._v(" 第一版，抄的抄的")]),t._v(" "),e("p",[t._v("执行用时 :152 ms, 在所有 cpp 提交中击败了22.12%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :24.5 MB, 在所有 cpp 提交中击败了25.49%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('static bool tmp(string a, string b) {\n\tif (a.size() != b.size()) {\n\t\treturn a.size() > b.size();\n\t}\n\telse {\n\t\treturn a < b;\n\t}\n}\n\nstring findLongestWord(string s, vector<string>& d) {\n\tif (s.size() == 0 || d.size() == 0) return "";\n\tvector<string> ans;\n\tfor (auto str : d) {\n\t\tqueue<char> que;\n\t\tfor (auto ch : str) {\n\t\t\tque.push(ch);\n\t\t}\n\t\tfor (auto &ch : s) {\n\t\t\tif (ch == que.front()) {\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\tif (que.empty()) ans.push_back(str);\n\t}\n\tif (ans.size() == 0) return "";\n\tsort(ans.begin(), ans.end(), tmp);\n\treturn ans[0];\n}\n')])])]),e("h4",{attrs:{id:"第二版-看的别人的法子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-看的别人的法子"}},[t._v("#")]),t._v(" 第二版，看的别人的法子")]),t._v(" "),e("p",[t._v("执行用时 :100 ms, 在所有 cpp 提交中击败了63.72%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :16 MB, 在所有 cpp 提交中击败了87.25%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('string findLongestWord(string s, vector<string> & d) {\n\t\tint n = d.size(), ns = s.size();\n\t\tstring res = "";\n\t\tsort(d.begin(), d.end());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = 0, k = 0, len1 = d[i].size(), len2 = s.size();\n\t\t\twhile (j < len1 && k < len2) {\n\t\t\t\tif (d[i][j] == s[k]) {\n\t\t\t\t\tj++;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\telse k++;\n\t\t\t}\n\t\t\tif (j == len1 && len1 > res.size()) res = d[i];\n\t\t}\n\t\treturn res;\n\t}\n')])])]),e("p",{attrs:{id:"区间列表的交集"}}),t._v(" "),e("h3",{attrs:{id:"_986-区间列表的交集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_986-区间列表的交集"}},[t._v("#")]),t._v(" 986. 区间列表的交集")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/interval-list-intersections/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定两个由一些"),e("strong",[t._v("闭区间")]),t._v("组成的列表，每个区间列表都是成对不相交的，并且已经排序。")]),t._v(" "),e("p",[t._v("返回这两个区间列表的交集。")]),t._v(" "),e("p",[e("em",[t._v("（形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）")])]),t._v(" "),e("p",[e("strong",[t._v("示例：")])]),t._v(" "),e("p",[e("strong",[e("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/02/interval1.png",alt:"img"}})])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]\n输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n注意：输入和所需的输出都是区间对象组成的列表，而不是数组或列表。\n")])])]),e("p",[e("strong",[t._v("提示：")])]),t._v(" "),e("ol",[e("li",[e("code",[t._v("0 <= A.length < 1000")])]),t._v(" "),e("li",[e("code",[t._v("0 <= B.length < 1000")])]),t._v(" "),e("li",[e("code",[t._v("0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9")])])]),t._v(" "),e("h4",{attrs:{id:"第一版-自己做的-好好分析即可"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己做的-好好分析即可"}},[t._v("#")]),t._v(" 第一版 ，自己做的，好好分析即可")]),t._v(" "),e("p",[t._v("执行用时 :56 ms, 在所有 cpp 提交中击败了94.15%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :15.9 MB, 在所有 cpp 提交中击败了5.88%的用户")]),t._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\t\t\n\nvector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n    if (A.empty() || B.empty()) return {};\n\tint i=0,j=0,left = A.size(), right = B.size();\n\tvector<vector<int>> res;\n\twhile (i < left && j < right) {\n\t\tint low = max(A[i][0],B[j][0]);\n\t\tint high = min(A[i][1], B[j][1]);\nif (low < high) {\n\t\t\tres.push_back({ low,high });\n\t\t\tif (high == A[i][1] && high == B[j][1]) { ++i; ++j; }\n\t\t\telse if (high == A[i][1]) ++i;\n\t\t\telse\n\t\t\t\t++j;\n\t\t}\n\t\telse if (low == high) { \n\t\t\tres.push_back({ low,high });\n\t\t\tif (high == A[i][1] && high == B[j][1]) { ++i; ++j; }\n\t\t\telse if (high == A[i][1]) ++i;\n\t\t\telse\n\t\t\t\t++j;\n\t\t}\n\t\telse if(low>high)\n\t\t{\n\t\t\tif (high == A[i][1] && high == B[j][1]) { ++i; ++j; }\n\t\t\telse if (high == A[i][1]) ++i;\n\t\t\telse\n\t\t\t\t++j;\n\t\t}\n\t\t//cout << low << " " << high <<" i "<<i<<" j "<<j<< endl;\n\n}\n\nreturn res;\n    \n}\n')])])]),e("h4",{attrs:{id:"第二版-加了一点空间改进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-加了一点空间改进"}},[t._v("#")]),t._v(" 第二版，加了一点空间改进")]),t._v(" "),e("p",[t._v("执行用时 :52 ms, 在所有 cpp 提交中击败了97.07%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :15.4 MB, 在所有 cpp 提交中击败了5.88%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n\n\tif (A.empty() || B.empty()) return {};\n\n\tint i=0,j=0,left = A.size(), right = B.size();\n\n\tvector<vector<int>> res;\n\n\tres.reserve(left + right);\n\n\twhile (i < left && j < right) {\n\n\t\tint low = max(A[i][0],B[j][0]);\n\n\t\tint high = min(A[i][1], B[j][1]);\n\n\n\n\t\t\tif (low < high) {\n\n\t\t\t\tres.push_back({ low,high });\n\n\t\t\t\tif (high == A[i][1] && high == B[j][1]) { ++i; ++j; }\n\n\t\t\t\telse if (high == A[i][1]) ++i;\n\n\t\t\t\telse\n\n\t\t\t\t\t++j;\n\n\t\t\t}\n\n\t\t\telse if (low == high) { \n\n\t\t\t\tres.push_back({ low,high });\n\n\t\t\t\tif (high == A[i][1] && high == B[j][1]) { ++i; ++j; }\n\n\t\t\t\telse if (high == A[i][1]) ++i;\n\n\t\t\t\telse\n\n\t\t\t\t\t++j;\n\n\t\t\t}\n\n\t\t\telse if(low>high)\n\n\t\t\t{\n\n\t\t\t\tif (high == A[i][1] && high == B[j][1]) { ++i; ++j; }\n\n\t\t\t\telse if (high == A[i][1]) ++i;\n\n\t\t\t\telse\n\n\t\t\t\t\t++j;\n\n\t\t\t}\n\n\t\t\t//cout << low << " " << high <<" i "<<i<<" j "<<j<< endl;\n\n\n\t}\n\n\n\treturn res;\n\n\n}\n')])])]),e("p",{attrs:{id:"最大连续的个数"}}),t._v(" "),e("h3",{attrs:{id:"_1004-最大连续1的个数-iii-我还是太菜了-不会不会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1004-最大连续1的个数-iii-我还是太菜了-不会不会"}},[t._v("#")]),t._v(" 1004. 最大连续1的个数 III   我还是太菜了，不会不会")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/max-consecutive-ones-iii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个由若干 "),e("code",[t._v("0")]),t._v(" 和 "),e("code",[t._v("1")]),t._v(" 组成的数组 "),e("code",[t._v("A")]),t._v("，我们最多可以将 "),e("code",[t._v("K")]),t._v(" 个值从 0 变成 1 。")]),t._v(" "),e("p",[t._v("返回仅包含 1 的最长（连续）子数组的长度。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2\n输出：6\n解释： \n[1,1,1,0,0,1,1,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 6。\n")])])]),e("p",[e("strong",[t._v("示例 2：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\n输出：10\n解释：\n[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 10。\n")])])]),e("p",[e("strong",[t._v("提示：")])]),t._v(" "),e("ol",[e("li",[e("code",[t._v("1 <= A.length <= 20000")])]),t._v(" "),e("li",[e("code",[t._v("0 <= K <= A.length")])]),t._v(" "),e("li",[e("code",[t._v("A[i]")]),t._v(" 为 "),e("code",[t._v("0")]),t._v(" 或 "),e("code",[t._v("1")])])]),t._v(" "),e("h4",{attrs:{id:"第一版-超时了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-超时了"}},[t._v("#")]),t._v(" 第一版，超时了....")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int longestOnes(vector<int>& A, int K) {\n\tif (A.size() == K) return A.size();\n\tsize_t len = A.size();\n\tsize_t temp=0,result=0,zeroCut=0;\n\tfor (size_t i = 0; i < len;++i) {\n\t\tzeroCut = 0;\n\t\ttemp = 0;\n\t\twhile (i < len&&A[i] == 1) {\n\t\t\ti++;\n\t\t\ttemp++;\n\t\t}\n\t\tfor (size_t j = i; j < len; ) {\n\t\t\tif (zeroCut < K&&A[j] == 0 ) {\n\t\t\t\ttemp++;\n\t\t\t\tzeroCut++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if (zeroCut < K&&A[j] == 1 )\n\t\t\t{\n\t\t\t\ttemp++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (zeroCut == K) { \n\t\t\t\twhile (j<len && A[j++] == 1) temp++;\n\t\t\t\tbreak; \n\t\t\t}\n\n\t\t}\n\n\t\tresult = max(result, temp);\n\t}\n\n\treturn result;\n\n}\n")])])]),e("h4",{attrs:{id:"第二版-想维持一个滑动窗口-还是没做出来"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-想维持一个滑动窗口-还是没做出来"}},[t._v("#")]),t._v(" 第二版，想维持一个滑动窗口，还是没做出来")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int longestOnes(vector<int>& A, int K) {\n\tif (A.size() == K) return A.size();\n\tsize_t len = A.size();\n\tsize_t temp=0,result=0,zeroCut=0;\n\tqueue<int> res;\n\tfor (size_t i = 0; i < len;++i) {\n\t\tif (A[i] == 1) {\n\t\t\tres.push(1);\n\t\t\ttemp++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres.push(0);\n\t\t\ttemp++; \n\t\t\tzeroCut++;\n\t\t}\n\t\tif (zeroCut == K) {\n\t\t\tresult = max(result, temp);\n\t\t}\n\t\telse if(zeroCut==K+1){\n\t\t\ttemp = temp - 1;\n\t\t\twhile (res.front() != 0) res.pop();//直到遇到第一个0；\n\t\t\tres.pop();//将 0 pop出去\n\t\t\tzeroCut = K;\n\t\t\tresult = max(result, temp);\n\t\t\ttemp = res.size();\n\t\t}\n\t}\n\n\treturn result;\n\n}\n\n")])])]),e("h4",{attrs:{id:"第三版-看的别人的方法-真的觉得自己蠢的不要不要的-呜呜呜-感觉自己是真的蠢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三版-看的别人的方法-真的觉得自己蠢的不要不要的-呜呜呜-感觉自己是真的蠢"}},[t._v("#")]),t._v(" 第三版，看的别人的方法，真的觉得自己蠢的不要不要的...呜呜呜，"),e("strong",[t._v("感觉自己是真的蠢")])]),t._v(" "),e("p",[t._v("执行用时 :56 ms, 在所有 cpp 提交中击败了95.70%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :13.8 MB, 在所有 cpp 提交中击败了83.98%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int longestOnes(vector<int>& A, int K) {\n\t//count用来统计窗口中0的个数\n\tint left = 0, right = 0, count = 0, result = 0, size = A.size();\n\n\twhile (right < size)\n\t{\n\t\tif(A[right]==0)\n\t\t\tcount += 1;\n\t\twhile (count > K)//当窗口内0的个数大于K时，需要缩小窗口\n\t\t{\n\t\t\tif(A[left]==0)\n\t\t\t\tcount -=1;\n\t\t\tleft++;\n\t\t}\n\t\t//窗口内0的个数小于等于k时，也就是可以该窗口内的0都可以替换，根据该窗口长度来确定是否更新result\n\t\tresult = max(result, right - left + 1);\n\t\tright++;\n\t}\n\treturn result;\n}\n")])])]),e("p",{attrs:{id:"满足条件的子序列数目"}}),t._v(" "),e("h3",{attrs:{id:"_1498-满足条件的子序列数目"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1498-满足条件的子序列数目"}},[t._v("#")]),t._v(" 1498. 满足条件的子序列数目")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给你一个整数数组 "),e("code",[t._v("nums")]),t._v(" 和一个整数 "),e("code",[t._v("target")]),t._v(" 。")]),t._v(" "),e("p",[t._v("请你统计并返回 "),e("code",[t._v("nums")]),t._v(" 中能满足其最小元素与最大元素的 "),e("strong",[t._v("和")]),t._v(" 小于或等于 "),e("code",[t._v("target")]),t._v(" 的 "),e("strong",[t._v("非空")]),t._v(" 子序列的数目。")]),t._v(" "),e("p",[t._v("由于答案可能很大，请将结果对 10^9 + 7 取余后返回。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：nums = [3,5,6,7], target = 9\n输出：4\n解释：有 4 个子序列满足该条件。\n[3] -> 最小元素 + 最大元素 <= target (3 + 3 <= 9)\n[3,5] -> (3 + 5 <= 9)\n[3,5,6] -> (3 + 6 <= 9)\n[3,6] -> (3 + 6 <= 9)\n")])])]),e("p",[e("strong",[t._v("示例 2：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：nums = [3,3,6,8], target = 10\n输出：6\n解释：有 6 个子序列满足该条件。（nums 中可以有重复数字）\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]\n")])])]),e("p",[e("strong",[t._v("示例 3：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：nums = [2,3,3,4,6,7], target = 12\n输出：61\n解释：共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）\n有效序列总数为（63 - 2 = 61）\n")])])]),e("p",[e("strong",[t._v("示例 4：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：nums = [5,2,4,1,7,6,8], target = 16\n输出：127\n解释：所有非空子序列都满足条件 (2^7 - 1) = 127\n")])])]),e("p",[e("strong",[t._v("提示：")])]),t._v(" "),e("ul",[e("li",[e("code",[t._v("1 <= nums.length <= 10^5")])]),t._v(" "),e("li",[e("code",[t._v("1 <= nums[i] <= 10^6")])]),t._v(" "),e("li",[e("code",[t._v("1 <= target <= 10^6")])])]),t._v(" "),e("h4",{attrs:{id:"_1、排序-双指针-数据预处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、排序-双指针-数据预处理"}},[t._v("#")]),t._v(" 1、排序+ 双指针 + 数据预处理")]),t._v(" "),e("p",[t._v("执行用时：412 ms, 在所有 C++ 提交中击败了79.43%的用户")]),t._v(" "),e("p",[t._v("内存消耗：50.1 MB, 在所有 C++ 提交中击败了100.00%的用户")]),t._v(" "),e("p",[t._v("1.算组合数需要多次算 2 的幂，所以直接把幂运算的结果存在数组 v 里\n2.求子序列不必保持数组顺序，先把数据排序，方便下一步\n3.滑动窗口，先固定左边界，然后找右边界，右边界值尽量大且满足左边界值 + 右边界值 < target，该区间的组合数为 2 的 n-1 次幂，n 为区间元素个数")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    int numSubseq(vector<int>& nums, int target) {\n\tint mod = 1e9 + 7;\n\tsort(nums.begin(), nums.end());\n\tint n = nums.size(), res = 0;\n\tvector<int>pw(n,0);\n\tpw[0] = 1;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tpw[i] = (pw[i - 1] * 2) % mod;\n\t}\n\tfor (int i = 0, j = n - 1; i < n; i++)\n\t{\n\t\twhile (i <= j && nums[i] + nums[j] > target) j--;\n\t\tif (i > j) break;\n\t\tres = (res + pw[j - i]) % mod;//固定住底下一位，最多就p[j-i]种，\n\t\t//比如 i=1 j =2，就两种情况 一是nums[i]，二是nums[i]和nums[j] ，所以是pw[j-i]\n\t}\n\treturn res;\n    }\n")])])]),e("p",[t._v("解析：https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/solution/man-zu-tiao-jian-de-zi-xu-lie-shu-mu-by-leetcode-s/")])])}),[],!1,null,null,null);n.default=a.exports}}]);