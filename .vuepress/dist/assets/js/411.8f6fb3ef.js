(window.webpackJsonp=window.webpackJsonp||[]).push([[411],{824:function(t,n,e){"use strict";e.r(n);var s=e(62),r=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",{attrs:{id:"简化路径"}}),t._v(" "),e("h3",{attrs:{id:"_71-简化路径"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_71-简化路径"}},[t._v("#")]),t._v(" 71. 简化路径")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/simplify-path/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。")]),t._v(" "),e("p",[t._v("在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径")]),t._v(" "),e("p",[t._v("请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v('输入："/home/"\n输出："/home"\n解释：注意，最后一个目录名后面没有斜杠。\n示例 2：')]),t._v(" "),e("p",[t._v('输入："/../"\n输出："/"\n解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。\n示例 3：')]),t._v(" "),e("p",[t._v('输入："/home//foo/"\n输出："/home/foo"\n解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n示例 4：')]),t._v(" "),e("p",[t._v('输入："/a/./b/../../c/"\n输出："/c"\n示例 5：')]),t._v(" "),e("p",[t._v('输入："/a/../../b/../c//.//"\n输出："/c"\n示例 6：')]),t._v(" "),e("p",[t._v('输入："/a//b////c/d//././/.."\n输出："/a/b/c"')]),t._v(" "),e("h4",{attrs:{id:"第一版-看别人的-用vector比栈方便"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-看别人的-用vector比栈方便"}},[t._v("#")]),t._v(" 第一版，看别人的，用vector比栈方便")]),t._v(" "),e("p",[t._v("执行用时 :12 ms, 在所有 cpp 提交中击败了70.22%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :10 MB, 在所有 cpp 提交中击败了90.52%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(' string simplifyPath(string path) {\n  \tstring result;\n\tvector<string> que;\n\tfor (auto i = 0; i < path.size(); ++i)//这个 i++ 是跳过 /号的\n\t{\n\t\tstring temp="";\n\t\twhile (path[i] != \'/\' && i < path.size())//遇到 / 则跳出，然后去判断当前temp是什么情况\n\t\t{\n\t\t\ttemp += path[i++];\n\t\t}\n\t\tif (temp == ".")\n\t\t\tcontinue;\n\t\telse if (temp == "..")\n\t\t{\n\t\t\tif (!que.empty()) //如果为空，已经跳不出去了,直接continue就可以了,不为空就把当前末尾pop出去\n\t\t\t\tque.pop_back();\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\telse if (temp.size() != 0)\n\t\t\tque.push_back(temp);\n\t}\n\tfor (int i = 0; i < que.size(); i++)\n\t{\n\t\tresult += \'/\';\n\t\tresult.append(que[i]);\n\t}\n\treturn result.size() == 0 ? "/" : result;\n    }\n')])])]),e("h4",{attrs:{id:"第二版-稍微改进一点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-稍微改进一点"}},[t._v("#")]),t._v(" 第二版，稍微改进一点")]),t._v(" "),e("p",[t._v("执行用时 :8 ms, 在所有 cpp 提交中击败了91.91%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :9.8 MB, 在所有 cpp 提交中击败了94.78%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('string simplifyPath(string path) {\n\tstring result;\n\tvector<string> que;\n\tfor (unsigned i = 0; i < path.size(); ++i)//这个 i++ 是跳过 /号的\n\t{\n\t\tstring temp="";\n\t\twhile (path[i] != \'/\' && i < path.size())//遇到 / 则跳出，然后去判断当前temp是什么情况\n\t\t{\n\t\t\ttemp += path[i++];\n\t\t}\n\t\tif (temp == ".")\n\t\t\tcontinue;\n\t\telse if (temp == "..")\n\t\t{\n\t\t\tif (!que.empty()) //如果为空，已经跳不出去了,直接continue就可以了,不为空就把当前末尾pop出去\n\t\t\t\tque.pop_back();\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\telse if (temp.size() != 0)\n\t\t\tque.push_back(temp);\n\t}\n\tfor (unsigned i = 0; i < que.size(); i++)\n\t{\n\t\tresult += \'/\';\n\t\tresult.append(que[i]);\n\t}\n\n\tif (result.size() == 0) return "/";\n\telse return result;\n\n}\n')])])]),e("p",{attrs:{id:"字符串解码"}}),t._v(" "),e("h3",{attrs:{id:"_394-字符串解码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_394-字符串解码"}},[t._v("#")]),t._v(" 394. 字符串解码")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/decode-string/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个经过编码的字符串，返回它解码后的字符串。")]),t._v(" "),e("p",[t._v("编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。")]),t._v(" "),e("p",[t._v("你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。")]),t._v(" "),e("p",[t._v("此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。")]),t._v(" "),e("p",[t._v("示例:")]),t._v(" "),e("p",[t._v('s = "3[a]2[bc]", 返回 "aaabcbc".\ns = "3[a2[c]]", 返回 "accaccacc".\ns = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".')]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的"}},[t._v("#")]),t._v(" 第一版，自己写的")]),t._v(" "),e("p",[t._v("执行用时 :8 ms, 在所有 C++ 提交中击败了26.58%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.9 MB, 在所有 C++ 提交中击败了57.94%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("string decodeString(string s) {\n\n\tstring res,temp,countStr;\n\tint count;\n\n\tfor (auto i : s) {\n\t\tcount = 0;\n\t\ttemp = \"\";\n\t\tcountStr = \"\";\n\t\tif (i != ']')\n\t\t\tres.push_back(i);\n\t\telse {\n\t\t\twhile (res.back() != '[')//直到遇到了[\n\t\t\t{\n\t\t\t\ttemp += res.back();\n\t\t\t\tres.pop_back();\n\t\t\t}\n\t\t\tres.pop_back();//将 [ 推出去\n\t\t\t\n\t\t\twhile (!res.empty() && res.back() >= '0' && res.back() <= '9') {\n\t\t\t\tcountStr += res.back();\n\t\t\t\tres.pop_back();\t\t\t\n\t\t\t}\n\t\t\treverse(countStr.begin(), countStr.end());\n\t\t\tcount = stod(countStr, 0);\n\t\t\treverse(temp.begin(),temp.end());\n\n\t\t\tfor (int j = 0; j < count; ++j) res += temp;\n\t\t\t\n\t\t}\n\n\t}\n\treturn res;\n}\n")])])]),e("p",{attrs:{id:"移掉位数字"}}),t._v(" "),e("h3",{attrs:{id:"_402-移掉k位数字-确实不会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_402-移掉k位数字-确实不会"}},[t._v("#")]),t._v(" 402. 移掉K位数字 确实不会")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/remove-k-digits/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。")]),t._v(" "),e("p",[t._v("注意:")]),t._v(" "),e("p",[t._v("num 的长度小于 10002 且 ≥ k。\nnum 不会包含任何前导零。\n示例 1 :")]),t._v(" "),e("p",[t._v('输入: num = "1432219", k = 3\n输出: "1219"\n解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。\n示例 2 :')]),t._v(" "),e("p",[t._v('输入: num = "10200", k = 1\n输出: "200"\n解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。\n示例 3 :')]),t._v(" "),e("p",[t._v('输入: num = "10", k = 2\n输出: "0"\n解释: 从原数字移除所有的数字，剩余为空就是0。')]),t._v(" "),e("p",{attrs:{id:"函数的独占时间"}}),t._v(" "),e("h3",{attrs:{id:"_636-函数的独占时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_636-函数的独占时间"}},[t._v("#")]),t._v(" 636. 函数的独占时间")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/exclusive-time-of-functions/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给出一个非抢占单线程CPU的 n 个函数运行日志，找到函数的独占时间。")]),t._v(" "),e("p",[t._v("每个函数都有一个唯一的 Id，从 0 到 n-1，函数可能会递归调用或者被其他函数调用。")]),t._v(" "),e("p",[t._v('日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如："0:start:0" 表示函数 0 从 0 时刻开始运行。"0🔚0" 表示函数 0 在 0 时刻结束。')]),t._v(" "),e("p",[t._v("函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。")]),t._v(" "),e("p",[t._v("示例 1:")]),t._v(" "),e("p",[t._v('输入:\nn = 2\nlogs =\n["0:start:0",\n"1:start:2",\n"1🔚5",\n"0🔚6"]\n输出:[3, 4]\n说明：\n函数 0 在时刻 0 开始，在执行了  2个时间单位结束于时刻 1。\n现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。\n函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。\n所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。\n说明：')]),t._v(" "),e("p",[t._v("输入的日志会根据时间戳排序，而不是根据日志Id排序。\n你的输出会根据函数Id排序，也就意味着你的输出数组中序号为 0 的元素相当于函数 0 的执行时间。\n两个函数不会在同时开始或结束。\n函数允许被递归调用，直到运行结束。\n1 <= n <= 100")]),t._v(" "),e("h4",{attrs:{id:"第一版-看了别人的思路-真的厉害"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-看了别人的思路-真的厉害"}},[t._v("#")]),t._v(" 第一版，看了别人的思路，真的厉害")]),t._v(" "),e("p",[t._v("执行用时 :24 ms, 在所有 cpp 提交中击败了99.12%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :11.2 MB, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" vector<int> exclusiveTime(int n, vector<string>& logs) {\n    vector<int> result(n, 0);\n\t\tstack<pair<int, int>> myStack;//辅助栈，<first, second>分别代表<函数id，起始时间>\n\t\t//扫描所有log\n\t\tfor (auto& log : logs) {\n\t\t\tstring operation = \"\";//id的操作，“start”或者“end”\n\t\t\tint funcId = 0, timeStamp = 0, index = 0, logSize = log.size();//log的函数id、操作时间戳\n\t\t\t//第一步：读取函数id\n\t\t\twhile (log[index] != ':') {\n\t\t\t\tfuncId = funcId * 10 + log[index++] - '0';\n\t\t\t}\n\t\t\tindex += 1;//跳过 : \n\t\t\t//第二步：读取操作类型\n\t\t\twhile (log[index] != ':') {\n\t\t\t\toperation += log[index++];\n\t\t\t}\n\t\t\tindex += 1; //再次跳过 :\n\t\t\t//第三步：读取时间戳\n\t\t\twhile (index < logSize) {\n\t\t\t\ttimeStamp = timeStamp * 10 + log[index++] - '0';\n\t\t\t}\n\t\t\t//第四步：根据操作进行不同的处理\n\t\t\tif (operation == \"start\") {\n\t\t\t\t//如果是函数start，直接放入stack中\n\t\t\t\tmyStack.push({ funcId, timeStamp });\n\t\t\t}\n\t\t\telse {//函数end的情况\n\t\t\t\tint runTime = timeStamp - myStack.top().second + 1;//计算栈顶id运行时间\n\t\t\t\tmyStack.pop();\n\t\t\t\tresult[funcId] += runTime;//加入到总时间中\n\t\t\t\t//如果此时栈还不为空，则说明当前栈顶函数里面嵌套了当前函数id，需要减去当前函数运行的时间\n\t\t\t\tif (!myStack.empty()) {\n\t\t\t\t\tresult[myStack.top().first] -= runTime;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result; \n    }\n")])])]),e("h4",{attrs:{id:"第二版-自己复现一遍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-自己复现一遍"}},[t._v("#")]),t._v(" 第二版，自己复现一遍")]),t._v(" "),e("p",[t._v("执行用时 :28 ms, 在所有 cpp 提交中击败了93.86%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :11.1 MB, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('vector<int> exclusiveTime(int n, vector<string>& logs) {//自己复现一编\n\tvector<int> res(n,0);\n\tstack<pair<int, int>>st;//函数ID和起始时间的映射\n\n\tfor (auto& log : logs) {\n\t\t\t\t\n\t\tint funID = 0, startTime = 0, logSize=log.size(), index=0;\n\t\tstring opera= "";\n\t\twhile (log[index] != \':\') {//取的函数ID\n\t\t\tfunID = funID * 10 + log[index++] - \'0\';\n\t\t}\n\t\tindex++;//跳过 : 号\n\t\t//cout << "funID" << funID << endl;\n\t\twhile (log[index] != \':\') {//取的开始还是结束符号\n\t\t\topera +=  log[index++];\n\t\t}\n\t\t//cout << "opera" << opera << endl;\n\t\tindex++;//再次跳过 :号\n\n\t\twhile (index<logSize) {//取的操作时间\n\t\t\tstartTime = startTime * 10 + log[index++] - \'0\';\n\t\t}\n\t\t//cout << "startTime" << startTime << endl;\n\t\tif (opera == "start") {//存入开始时间\n\t\t\tst.push({ funID,startTime });\n\t\t}\n\t\telse {\n\t\t\tint totalRunTime = startTime - st.top().second + 1;\n\t\t\t//cout << "totaltime " << totalRunTime << endl;\n\t\t\tres[funID] += totalRunTime;//以0为中介，属于自己的就加上则减\n\t\t\tst.pop();\n\t\t\tif (!st.empty()) {\n\t\t\t\tres[st.top().first] -= totalRunTime;//不属于自己的就减去\n\t\t\t}\n\t\t}\n\n\t}\n\treturn res;\n\t\n}\n')])])]),e("h4",{attrs:{id:"第三种-别的方法-学到了-但是执行时间较久"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三种-别的方法-学到了-但是执行时间较久"}},[t._v("#")]),t._v(" 第三种，别的方法，学到了,但是执行时间较久")]),t._v(" "),e("p",[t._v("学到了istringstream的法子")]),t._v(" "),e("p",[t._v("执行用时 :76 ms, 在所有 cpp 提交中击败了22.81%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :11.1 MB, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<int> res(n, 0);\n\tstack<pair<int, int>> stk;\n\n\tfor (auto &log : logs)\n\t{\n\t\tistringstream ss(log);//初始化一个string流\n\t\tstring s1, s2, s3;\n\t\tgetline(ss, s1, ':');//以 ; 为阶段符，将ss符合中的内容输入到 s1中，也就是输入了函数ID，此时ss中被取走的有s1和 “;” \n\t\tgetline(ss, s2, ':');//，将s1+\";\"去除后,对于剩下的ss以 ; 为阶段符，将ss符合中的内容输入到 s2中，也就是输入了start或者end\n\t\tgetline(ss, s3);//，默认是以 \\n 为结束符号的\n\n\t\tint id = stoi(s1), time = stoi(s3);\n\t\tstring action = s2;\n\t\t\n\t\tif (action == \"start\")\n\t\t{\n\t\t\tif (!stk.empty())\n\t\t\t\tres[stk.top().first] += time - stk.top().second;\n\t\t\tstk.push({ id,time });\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<int, int> p = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tres[p.first] += time - p.second + 1;\n\t\t\tif (!stk.empty())\n\t\t\t\tstk.top().second = time + 1;\n\t\t}\n\n\t}\n\n\treturn res;\n")])])]),e("p",{attrs:{id:"每日温度"}}),t._v(" "),e("h3",{attrs:{id:"_739-每日温度-经典"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_739-每日温度-经典"}},[t._v("#")]),t._v(" 739. 每日温度  经典")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/daily-temperatures/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。")]),t._v(" "),e("p",[t._v("例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。")]),t._v(" "),e("p",[t._v("提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。")]),t._v(" "),e("h4",{attrs:{id:"第一版-超时了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-超时了"}},[t._v("#")]),t._v(" 第一版，超时了")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\n vector<int> dailyTemperatures(vector<int>& T) {\n    vector<int> res;\n\tres.push_back(0);\n\tint len = T.size();\n\tfor (int i=len-2; i>=0; --i) {\n\t\tint j = i +1;\n\t\twhile (j != len) {\n\t\t\tif (T[i] < T[j]) { res.push_back(j - i); break; }\n\t\t\telse\n\t\t\t\tj++;\n\t\t}\n\t\tif (j == len) res.push_back(0);\n\t}\n\treverse(res.begin(), res.end());\n\n\treturn res;  \n    }\n")])])]),e("h4",{attrs:{id:"第二版-看的别人的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-看的别人的"}},[t._v("#")]),t._v(" 第二版，看的别人的")]),t._v(" "),e("p",[t._v("https://leetcode-cn.com/problems/daily-temperatures/solution/jie-ti-si-lu-by-pulsaryu/")]),t._v(" "),e("p",[t._v("执行用时 :224 ms, 在所有 cpp 提交中击败了97.42%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :14.7 MB, 在所有 cpp 提交中击败了94.18%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    vector<int> dailyTemperatures(vector<int>& T) {\n\tint len = T.size();\n\tvector<int> res(len);\n\tres[len - 1] = 0;\n\tfor (int i = len-2; i >=0 ;--i) {\n\n\t\tfor (int j = i + 1; j < len; j += res[j]) \n         // j+= result[j]是利用已经有的结果进行跳跃,只需要找比当前大的值进行比较即可，小于的直接跳过\n        {\n\t\t\tif (T[j] > T[i]) { res[i] = j - i; break; }\n\t\t\tif (res[j] == 0) { res[i] = 0; break; }\n\t\t}//遇到0表示后面不会有更大的值，那当然当前值就应该也为0\n\n\t}\n\treturn res;\n    }\n")])])]),e("h4",{attrs:{id:"第三版-稍微改进一点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三版-稍微改进一点"}},[t._v("#")]),t._v(" 第三版，稍微改进一点")]),t._v(" "),e("p",[t._v("执行用时 :228 ms, 在所有 cpp 提交中击败了95.98%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :14.6 MB, 在所有 cpp 提交中击败了95.15%的用户")]),t._v(" "),e("p",[e("strong",[t._v("res(len)时已经初始化为0了，所以可以去掉那两步赋值为0的部分")])]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<int> dailyTemperatures(vector<int>& T) {\n\t\n\tint len = T.size();\n\tvector<int> res(len);\n\t//res[len - 1] = 0;\n\tfor (int i = len-2; i >=0 ;--i) {\n\n\t\tfor (int j = i + 1; j < len; j += res[j]) {\n\t\t\tif (T[j] > T[i]) { res[i] = j - i; break; }\n\t\t\tif (res[j] == 0) {  break; }\n\t\t}\n\n\t}\n\treturn res;\n\n}\n")])])]),e("p",{attrs:{id:"括号的分数"}}),t._v(" "),e("h3",{attrs:{id:"_856-括号的分数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_856-括号的分数"}},[t._v("#")]),t._v(" 856. 括号的分数")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/score-of-parentheses/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：")]),t._v(" "),e("p",[t._v("() 得 1 分。\nAB 得 A + B 分，其中 A 和 B 是平衡括号字符串。\n(A) 得 2 * A 分，其中 A 是平衡括号字符串。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v('输入： "()"\n输出： 1\n示例 2：')]),t._v(" "),e("p",[t._v('输入： "(())"\n输出： 2\n示例 3：')]),t._v(" "),e("p",[t._v('输入： "()()"\n输出： 2\n示例 4：')]),t._v(" "),e("p",[t._v('输入： "(()(()))"\n输出： 6')]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("S 是平衡括号字符串，且只含有 ( 和 ) 。\n2 <= S.length <= 50")]),t._v(" "),e("h4",{attrs:{id:"第一版-抄的-看都看不太懂"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-抄的-看都看不太懂"}},[t._v("#")]),t._v(" 第一版 抄的，看都看不太懂...")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 C++ 提交中击败了76.89%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.2 MB, 在所有 C++ 提交中击败了92.86%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/*\n借鉴别人的 (()(())) = (()) + ((())) , 且  分数 = 2^(层数-1)\n出现 '(' 代表层数+1 ， 出现 ')' 代表层数 -1\n*/\nclass Solution {\npublic:\n    int scoreOfParentheses(string S) {\n        int deep=0,ans=0;\n        for(int i=0;i<S.length();i++){\n            if(S[i] == '(')deep++;\n            else deep--;\n            if(S[i]==')' && S[i-1]=='(') ans += 1 << deep;\n        }\n        return ans;\n    }\n};\n")])])]),e("p",{attrs:{id:"使括号有效的最少添加"}}),t._v(" "),e("h3",{attrs:{id:"_921-使括号有效的最少添加"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_921-使括号有效的最少添加"}},[t._v("#")]),t._v(" 921. 使括号有效的最少添加")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。")]),t._v(" "),e("p",[t._v("从形式上讲，只有满足下面几点之一，括号字符串才是有效的：")]),t._v(" "),e("p",[t._v("它是一个空字符串，或者\n它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者\n它可以被写作 (A)，其中 A 是有效字符串。\n给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v('输入："())"\n输出：1\n示例 2：')]),t._v(" "),e("p",[t._v('输入："((("\n输出：3\n示例 3：')]),t._v(" "),e("p",[t._v('输入："()"\n输出：0\n示例 4：')]),t._v(" "),e("p",[t._v('输入："()))(("\n输出：4')]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("S.length <= 1000\nS 只包含 '(' 和 ')' 字符。")]),t._v(" "),e("p",[t._v("执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.7 MB, 在所有 C++ 提交中击败了72.99%的用户")]),t._v(" "),e("h4",{attrs:{id:"第一版-队列-看完理解了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-队列-看完理解了"}},[t._v("#")]),t._v(" 第一版  队列，看完理解了")]),t._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int minAddToMakeValid(string S) {\n\tif (S.size() <= 1) return S.size();\n\tstack<char> st;\n\tst.push(S[0]);\n\tfor (int i = 1; i < S.size(); ++i) {\n\t\tif (S[i] == ')')\t\n\t\t{\n\t\t\tif (st.empty()) st.push(')');\n\t\t\telse if(st.top() == '(') st.pop(); \n\t\t\telse st.push(')');\n\t\t}\n\t\telse { \n\t\t\tst.push(S[i]);\n\t\t}\n\t}\n\tint cut = 0;\n\twhile (!st.empty()) {\n\t\tst.pop();\n\t\tcut++;\n\t}\n\treturn cut;\n}\n\n")])])]),e("h4",{attrs:{id:"第二版-自己隔天复现-还可以"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-自己隔天复现-还可以"}},[t._v("#")]),t._v(" 第二版  自己隔天复现，还可以")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 C++ 提交中击败了79.92%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.7 MB, 在所有 C++ 提交中击败了41.42%的用户")]),t._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<string> letterCombinations(string digits) {\n\tmap<char, string> mp = { {'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"} };//建立映射\n\tqueue<string> que;//借助队列\n\tvector<string> result;\n\tunsigned i, j,length;\n\tstring strTemp;\n\n\tfor (i = 0; i < mp[digits[0]].size(); ++i) { //首先将映射表的第一个元素的内容导入进去\n\t\tstrTemp.push_back(mp[digits[0]][i]);\n\t\tque.push(strTemp);\n\t\tstrTemp.clear();\n\t}\n\n\tfor (i = 1; i < digits.size(); ++i) {//头元素之外的其他元素\n\t\tlength = que.size();\n\t\twhile (length--) {//对于当前st的所有元素，挨个取出来与后面的进行组合\n\t\t\tstrTemp = que.front(); //把队列头拿出来处理\n\t\t\tfor (j = 0; j < mp[digits[i]].size(); ++j) {\n\t\t\t\tcout << strTemp + mp[digits[i]][j] << endl;\n\t\t\t\tque.push(strTemp + mp[digits[i]][j]);\n\t\t\t}\n\t\t\tque.pop(); //处理完，去除头部元素\n\t\t}\n\t}\n\n\twhile (!que.empty()) { //转存到vector上\n\t\tresult.push_back(que.front());\n\t\tque.pop();\n\t}\n\treturn result;\n}\n\n")])])]),e("p",{attrs:{id:"验证栈序列"}}),t._v(" "),e("h3",{attrs:{id:"_946-验证栈序列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_946-验证栈序列"}},[t._v("#")]),t._v(" 946. 验证栈序列")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/validate-stack-sequences/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定 pushed 和 popped 两个序列，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v("输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出：true\n解释：我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n示例 2：")]),t._v(" "),e("p",[t._v("输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出：false\n解释：1 不能在 2 之前弹出。")]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("0 <= pushed.length == popped.length <= 1000\n0 <= pushed[i], popped[i] < 1000\npushed 是 popped 的排列。")]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的-看错了-改了好久"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的-看错了-改了好久"}},[t._v("#")]),t._v(" 第一版，自己写的，看错了，改了好久")]),t._v(" "),e("p",[t._v("执行用时 :12 ms, 在所有 cpp 提交中击败了79.08%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.9 MB, 在所有 cpp 提交中击败了88.28%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n    if (pushed.size() != popped.size()) return false;\n\n\tstack<int> st;\n\tunsigned j=0,lenPush = pushed.size();\n\n\tfor (unsigned i = 0; i < lenPush && j<lenPush;++i) {\n\t\t//cout << "i:" << i << endl;\n\t\tst.push(pushed[i]);\n\t\tif (popped[j] != st.top())\n\t\t\tcontinue;\n\t\telse\n\t\t{\n\t\t\t//cout <<"1:" <<popped[j] << " " << st.top() << endl;\n\t\t\tst.pop();\n\t\t\tj++;\n\t\t\t//cout << "2:" << popped[j] <<" "<<j << endl;\n\t\t\tfor (int k = st.size() - 1; k >= 0; --k) {\n\t\t\t\t\n\t\t\t\t//cout << "3:" << popped[j] << " " << st.top() <<" j "<<j<< endl;\n\t\t\t\tif (!st.empty() && st.top() == popped[j]) {\n\t\t\t\t\tj++;\n\t\t\t\t\tst.pop();\n\t\t\t\t\t//cout << "4:" << popped[j] << " " << j << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\treturn st.empty() && j  == lenPush;\n        \n    }\n')])])]),e("p",{attrs:{id:"检查替换后的词是否有效"}}),t._v(" "),e("h3",{attrs:{id:"_1003-检查替换后的词是否有效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1003-检查替换后的词是否有效"}},[t._v("#")]),t._v(" 1003. 检查替换后的词是否有效")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/check-if-word-is-valid-after-substitutions/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v('给定有效字符串 "abc"。')]),t._v(" "),e("p",[t._v('对于任何有效的字符串 V，我们可以将 V 分成两个部分 X 和 Y，使得 X + Y（X 与 Y 连接）等于 V。（X 或 Y 可以为空。）那么，X + "abc" + Y 也同样是有效的。')]),t._v(" "),e("p",[t._v('例如，如果 S = "abc"，则有效字符串的示例是："abc"，"aabcbc"，"abcabc"，"abcabcababcc"。无效字符串的示例是："abccba"，"ab"，"cababc"，"bac"。')]),t._v(" "),e("p",[t._v("如果给定字符串 S 有效，则返回 true；否则，返回 false。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v('输入："aabcbc"\n输出：true\n解释：\n从有效字符串 "abc" 开始。\n然后我们可以在 "a" 和 "bc" 之间插入另一个 "abc"，产生 "a" + "abc" + "bc"，即 "aabcbc"。\n示例 2：')]),t._v(" "),e("p",[t._v('输入："abcabcababcc"\n输出：true\n解释：\n"abcabcabc" 是有效的，它可以视作在原串后连续插入 "abc"。\n然后我们可以在最后一个字母之前插入 "abc"，产生 "abcabcab" + "abc" + "c"，即 "abcabcababcc"。\n示例 3：')]),t._v(" "),e("p",[t._v('输入："abccba"\n输出：false\n示例 4：')]),t._v(" "),e("p",[t._v('输入："cababc"\n输出：false')]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("1 <= S.length <= 20000\n2、S[i] 为 'a'、'b'、或 'c'")]),t._v(" "),e("h4",{attrs:{id:"第一版-应该先判断是否为空再进行其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-应该先判断是否为空再进行其他"}},[t._v("#")]),t._v(" 第一版，应该先判断是否为空再进行其他")]),t._v(" "),e("p",[t._v("执行用时 :24 ms, 在所有 cpp 提交中击败了63.73%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :10.6 MB, 在所有 cpp 提交中击败了81.74%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("bool isValid(string S) {\n\tstack<char> st;\n\tfor (auto &ch : S) {\n\t\tif (st.empty()){\n\t\t\tst.push(ch);\n\t\t}\n\t\telse if (ch == 'c') {\n\t\t\tif (!st.empty() && st.top() == 'b'  ) { //在下一步删除前删除前，应该先判断是否为空再进行其他操作\n\t\t\t\tst.pop();\n\t\t\t\tif (!st.empty() && st.top() == 'a' ) //在下一步删除前删除前，应该先判断是否为空再进行其他操作\n\t\t\t\t\tst.pop();\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tst.push('b');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tst.push('c');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tst.push(ch);\n\t}\n\treturn st.empty();\n}\n")])])]),e("p",{attrs:{id:"反转每对括号间的子串"}}),t._v(" "),e("h3",{attrs:{id:"_1190-反转每对括号间的子串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1190-反转每对括号间的子串"}},[t._v("#")]),t._v(" 1190. 反转每对括号间的子串")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给出一个字符串 s（仅含有小写英文字母和括号）。")]),t._v(" "),e("p",[t._v("请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。")]),t._v(" "),e("p",[t._v("注意，您的结果中 不应 包含任何括号。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v('输入：s = "(abcd)"\n输出："dcba"\n示例 2：')]),t._v(" "),e("p",[t._v('输入：s = "(u(love)i)"\n输出："iloveu"\n示例 3：')]),t._v(" "),e("p",[t._v('输入：s = "(ed(et(oc))el)"\n输出："leetcode"\n示例 4：')]),t._v(" "),e("p",[t._v('输入：s = "a(bcdefghijkl(mno)p)q"\n输出："apmnolkjihgfedcbq"')]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("0 <= s.length <= 2000\ns 中只有小写英文字母和括号\n我们确保所有括号都是成对出现的")]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的-2"}},[t._v("#")]),t._v(" 第一版 自己写的")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 cpp 提交中击败了84.02%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.6 MB, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    string reverseParentheses(string s) {\n    stack<char> res;\n\tstring str=\"\";\n\tfor (auto i : s) {\n\t\tif(i==')'){\n\t\t\n\t\t\twhile (res.top() != '(') {\n\t\t\t\tstr += res.top();\n\t\t\t\tres.pop();\n\t\t\t}\n\t\t\tres.pop();//将'('推出去\n\n\t\t\tfor(auto j:str)\n\t\t\t{\n\t\t\t\tres.push(j);\n\t\t\t}\n\t\t\tstr = \"\";\n\n\t\t}\n\t\telse {\n\t\t\tres.push(i);\n\t\t}\n\n\t}\n\twhile (!res.empty()) {\n\t\tstr += res.top();\n\t\tres.pop();\n\t}\n\treverse(str.begin(), str.end());\n\treturn str;   \n    }\n")])])]),e("h4",{attrs:{id:"第二版-循环时使用引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-循环时使用引用"}},[t._v("#")]),t._v(" 第二版，循环时使用引用")]),t._v(" "),e("p",[t._v("执行用时 :0 ms, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.7 MB, 在所有 cpp 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" string reverseParentheses(string s) {\n    stack<char> res;\n\tstring str=\"\";\n\tfor (auto &i : s) { //使用引用有很大提升\n\t\tif(i==')'){\n\t\t\n\t\t\twhile (res.top() != '(') {\n\t\t\t\tstr += res.top();\n\t\t\t\tres.pop();\n\t\t\t}\n\t\t\tres.pop();//将'('推出去\n\n\t\t\tfor(auto &j:str)\n\t\t\t{\n\t\t\t\tres.push(j);\n\t\t\t}\n\t\t\tstr = \"\";\n\n\t\t}\n\t\telse {\n\t\t\tres.push(i);\n\t\t}\n\n\t}\n\twhile (!res.empty()) {\n\t\tstr += res.top();\n\t\tres.pop();\n\t}\n\treverse(str.begin(), str.end());//注意要反转一下\n\treturn str;   \n    }\n")])])]),e("p",{attrs:{id:"删除字符串中的所有相邻重复项"}}),t._v(" "),e("h3",{attrs:{id:"_1209-删除字符串中的所有相邻重复项-ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1209-删除字符串中的所有相邻重复项-ii"}},[t._v("#")]),t._v(" 1209. 删除字符串中的所有相邻重复项 II")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string-ii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。")]),t._v(" "),e("p",[t._v("你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。")]),t._v(" "),e("p",[t._v("在执行完所有删除操作后，返回最终得到的字符串。")]),t._v(" "),e("p",[t._v("本题答案保证唯一。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v('输入：s = "abcd", k = 2\n输出："abcd"\n解释：没有要删除的内容。\n示例 2：')]),t._v(" "),e("p",[t._v('输入：s = "deeedbbcccbdaa", k = 3\n输出："aa"\n解释：\n先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"\n再删除 "bbb"，得到 "dddaa"\n最后删除 "ddd"，得到 "aa"\n示例 3：')]),t._v(" "),e("p",[t._v('输入：s = "pbbcggttciiippooaais", k = 2\n输出："ps"')]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("1 <= s.length <= 10^5\n2 <= k <= 10^4\ns 中只含有小写英文字母。")]),t._v(" "),e("h4",{attrs:{id:"第一版-真的不会-抄的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-真的不会-抄的"}},[t._v("#")]),t._v(" 第一版，真的不会，抄的")]),t._v(" "),e("p",[t._v("执行用时 :52 ms, 在所有 C++ 提交中击败了23.22%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :10.4 MB, 在所有 C++ 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('string removeDuplicates(string s, int k) {\n\t//deeedbbcccbda\n\tstack<int>times;\n\tstack<char>st;\n\tfor (auto vi : s) {\n\t\tif (st.empty() || st.top() != vi)\n\t\t\tst.push(vi), times.push(1);\n\t\telse if (st.top() == vi)\n\t\t\t++times.top();\n\n\t\tif (times.top() == k) st.pop(), times.pop();\n\t}\n\n\tstring result="";\n\twhile (!st.empty()) {\n\t\tresult.insert(result.begin(), times.top(), st.top());\n\t\tst.pop(), times.pop();\n\t}\n\treturn result;\n}\n')])])]),e("h4",{attrs:{id:"第二版-稍微改进一点-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-稍微改进一点-2"}},[t._v("#")]),t._v(" 第二版，稍微改进一点")]),t._v(" "),e("p",[t._v("执行用时 :28 ms, 在所有 C++ 提交中击败了34.70%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :10.1 MB, 在所有 C++ 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('    string removeDuplicates(string s, int k) {\n\tstack<int>times;\n\tstack<char>st;\n\tfor (auto vi : s) {\n\t\tif (st.empty() || st.top() != vi)\n\t\t\tst.push(vi), times.push(1);\n\t\telse if (st.top() == vi)\n\t\t\t++times.top();\n\n\t\tif (times.top() == k) st.pop(), times.pop();\n\t}\n\n\tstring result="";\n\tint i,len;\n\tchar ch;\n\twhile (!st.empty()) {\n\t\t/*result.insert(result.begin(), times.top(), st.top());*/\n\t\tlen = times.top();\n\t\tch = st.top();\n\t\tfor ( i = 0; i < len; ++i) {\n\t\t\tresult += ch;\n\t\t}\n\t\tst.pop(), times.pop();\n\t}\n        \n    reverse(result.begin(),result.end());//很重要\n\treturn result;\n        \n    }\n')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);