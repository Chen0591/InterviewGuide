(window.webpackJsonp=window.webpackJsonp||[]).push([[327],{746:function(t,n,s){"use strict";s.r(n);var e=s(62),r=Object(e.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",{attrs:{id:"最长回文子串"}}),t._v(" "),s("h3",{attrs:{id:"_5-最长回文子串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-最长回文子串"}},[t._v("#")]),t._v(" 5. 最长回文子串")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/longest-palindromic-substring/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("给定一个字符串 "),s("code",[t._v("s")]),t._v("，找到 "),s("code",[t._v("s")]),t._v(" 中最长的回文子串。你可以假设 "),s("code",[t._v("s")]),t._v(" 的最大长度为 1000。")]),t._v(" "),s("p",[s("strong",[t._v("示例 1：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('输入: "babad"\n输出: "bab"\n注意: "aba" 也是一个有效答案。\n')])])]),s("p",[s("strong",[t._v("示例 2：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('输入: "cbbd"\n输出: "bb"\n')])])]),s("h4",{attrs:{id:"第一版-中间向外扩展法-自己写的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第一版-中间向外扩展法-自己写的"}},[t._v("#")]),t._v(" 第一版，中间向外扩展法，自己写的")]),t._v(" "),s("p",[t._v("执行用时 :124 ms, 在所有 cpp 提交中击败了47.66%的用户")]),t._v(" "),s("p",[t._v("内存消耗 :46.8 MB, 在所有 cpp 提交中击败了32.27%的用户")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('void Substrings(string &s,string &longestStr,int i,int j) {\n\n\tstring left = "", right = "";\n\tif (i == j) {\n\t\tright += s[j++];\n\t\ti--;\n\t}\n\twhile ( i>=0 && j<s.size() && s[i]==s[j]) {\n\t\tleft +=s[i--];\n\t\tright+=s[j++];\n\n\t}\n\n\tif (left.size() + right.size() > longestStr.size()) {\n\t\treverse(left.begin(), left.end());\n\t\tlongestStr = left + right;\n\t}\n\n}\n\nstring longestPalindrome(string s) {\n\tif (s.size() <= 1) return s;\n\tstring longestStr = "";\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tSubstrings(s, longestStr, i, i);\n\t\tSubstrings(s, longestStr, i, i+1);\n\n\t\tif (longestStr.size() == s.size()) break;//自身就是个回文子串，直接break就行\n\t}\n\n\treturn longestStr;\n\n}\n')])])]),s("h4",{attrs:{id:"第二版-标准dp解法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二版-标准dp解法"}},[t._v("#")]),t._v(" 第二版，标准DP解法")]),t._v(" "),s("p",[t._v("执行用时 :244 ms, 在所有 cpp 提交中击败了29.93%的用户")]),t._v(" "),s("p",[t._v("内存消耗 :18.9 MB, 在所有 cpp 提交中击败了39.03%的用户")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('string longestPalindrome(string s) {\n\tif (s.size() <= 1) return s;\n\tint n = s.size(),low=0,high=0,longLen=0;\n\tvector<vector<bool>> dp(n, vector<bool>(n, false));\n\tfor (int i = n-1; i >=0; --i) {\n\t\tfor (int j = i; j < n; ++j) {\n\t\t\tif (s[i] == s[j] && (j - i <= 1 || dp[i + 1][j - 1])) {\n\t\t\t\tdp[i][j] = true;\n\t\t\t\tif (j - i > longLen) {\n\t\t\t\t\tlongLen = j - i;\n\t\t\t\t\tlow = i;\n\t\t\t\t\thigh = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\n\tstring longestStr = "";\n\twhile (low <= high)\n\t\tlongestStr += s[low++];\n\treturn longestStr;\n\n}\n')])])]),s("p",{attrs:{id:"不同路径"}}),t._v(" "),s("p",{attrs:{id:"三角形最小路径和"}})])}),[],!1,null,null,null);n.default=r.exports}}]);