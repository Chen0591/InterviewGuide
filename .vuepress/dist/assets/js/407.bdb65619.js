(window.webpackJsonp=window.webpackJsonp||[]).push([[407],{819:function(t,n,e){"use strict";e.r(n);var s=e(62),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",{attrs:{id:"最小栈"}}),t._v(" "),e("h3",{attrs:{id:"_155-最小栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_155-最小栈"}},[t._v("#")]),t._v(" 155. 最小栈")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/min-stack/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。")]),t._v(" "),e("ul",[e("li",[t._v("push(x) -- 将元素 x 推入栈中。")]),t._v(" "),e("li",[t._v("pop() -- 删除栈顶的元素。")]),t._v(" "),e("li",[t._v("top() -- 获取栈顶元素。")]),t._v(" "),e("li",[t._v("getMin() -- 检索栈中的最小元素。")])]),t._v(" "),e("p",[e("strong",[t._v("示例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --\x3e 返回 -3.\nminStack.pop();\nminStack.top();      --\x3e 返回 0.\nminStack.getMin();   --\x3e 返回 -2.\n")])])]),e("h4",{attrs:{id:"第一版-双栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-双栈"}},[t._v("#")]),t._v(" 第一版，双栈")]),t._v(" "),e("p",[t._v("执行用时 :64 ms, 在所有 C++ 提交中击败了37.18%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :16.8 MB, 在所有 C++ 提交中击败了77.33%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class MinStack {\npublic:\n\t/** Initialize your data structure here. */\n\tMinStack() {\n\n\t}\n\n\t/** Push element x to the back of queue. */\n\tvoid push(int x) {\n\n\t\tstVal.push(x);\n\t\tif (stMin.empty() || x < stMin.top()) //双栈，同步保存当前最小值，如果是第一个x或者小于当前最小值，就把新的最小值存储进来\n\t\t\tstMin.push(x);\n\t\telse\n\t\t\tstMin.push(stMin.top());\n\t}\n\n\t/** Removes the element from in front of queue and returns that element. */\n\tvoid pop() {\n\n\t\tstMin.pop();\n\t\tstVal.pop();\n\t}\n\n\t/** Get the front element. */\n\tint top() {\n\n\t\treturn stVal.top();\n\t}\n\n\t/** Returns whether the queue is empty. */\n\tint getMin() {\n\t\treturn stMin.top();\n\t}\n\nprivate:\n\tstack<int> stVal, stMin;\n};\n")])])]),e("h4",{attrs:{id:"第二版-又一个思路-一次push两个进去"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-又一个思路-一次push两个进去"}},[t._v("#")]),t._v(" 第二版 ，又一个思路，一次push两个进去")]),t._v(" "),e("p",[t._v("每次push时，第一次push进x，第二次push当前的最小值")]),t._v(" "),e("p",[t._v("执行用时 :64 ms, 在所有 C++ 提交中击败了37.18%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :16.7 MB, 在所有 C++ 提交中击败了93.90%的用户")]),t._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class MinStack {\npublic:\n\t/** Initialize your data structure here. */\n\tMinStack() {\n\t}\n\n\t/** Push element x to the back of queue. */\n\tvoid push(int x) {\n\t\tif (st.empty()) {\n\t\t\tnumMin = x;\n\t\t\tst.push(x);\n\t\t\tst.push(x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumMin = min(numMin, x);\n\t\t\tst.push(x);\n\t\t\tst.push(numMin);\n\t\t}\n\n\t}\n\n\t/** Removes the element from in front of queue and returns that element. */\n\tvoid pop() {\n\t\tst.pop();\n\t\tst.pop();\n\t\tif(!st.empty()) //注意可能会有st为空的情况，直接写numMin=st.top()会报错，要注意更新最小值\n\t\t\tnumMin = st.top();\n\t}\n\n\t/** Get the front element. */\n\tint top() {\n\t\tint numMinTemp = st.top();//先保存最后的小的值\n\t\tst.pop();\n\t\tnumTemp = st.top();\n\t\tst.push(numMinTemp);\n\t\treturn numTemp; //不能返回局部变量的值以及地址\n\t}\n\n\t/** Returns whether the queue is empty. */\n\tint getMin() {\n\t\treturn st.top();\n\t}\n\nprivate:\n\tstack<int> st = {};\n\tint numMin, numTemp;\n};\n")])])]),e("p",[t._v("几个教训：")]),t._v(" "),e("p",[t._v("1、函数返回时，不能返回局部变量的值以及地址")]),t._v(" "),e("p",[t._v("2、注意边界检查，以及最小值的更新")]),t._v(" "),e("h4",{attrs:{id:"第三版-第二版的变形-但是快很多了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三版-第二版的变形-但是快很多了"}},[t._v("#")]),t._v(" 第三版 第二版的变形，但是快很多了")]),t._v(" "),e("p",[t._v("执行用时 :36 ms, 在所有 C++ 提交中击败了90.66%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :17 MB, 在所有 C++ 提交中击败了36.11%的用户")]),t._v(" "),e("p",[e("strong",[t._v("先输入最小值，再push当前值，这样get_top(),会快一点")])]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class MinStack {\npublic:\n\t/** Initialize your data structure here. */\n\tMinStack() {\n\n\t}\n\n\t/** Push element x to the back of queue. */\n\tvoid push(int x) {\n\t\tif (st.empty()) {\n\t\t\tnumMin = x;\n\t\t\tst.push(x);\n\t\t\tst.push(x);\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tnumMin = min(numMin, x);\n\t\t\tst.push(numMin);\n\t\t\tst.push(x);\n\t\t}\n\n\t}\n\n\t/** Removes the element from in front of queue and returns that element. */\n\tvoid pop() {\n\t\tst.pop();\n\t\tst.pop();\n\t\tif (!st.empty())\n\t\t{\n\t\t\tint numTemp = st.top();\n\t\t\tst.pop();\n\t\t\tnumMin = st.top();\n\t\t\tst.push(numTemp);\n\t\t}\n\t}\n\n\t/** Get the front element. */\n\tint top() {\n\n\t\treturn st.top();\n\t}\n\n\t/** Returns whether the queue is empty. */\n\tint getMin() {\n\t\tint numTempT = st.top();\n\t\tst.pop();\n\t\tnumTemp = st.top();\n\t\tst.push(numTempT);\n\t\treturn numTemp;\n\t}\n\nprivate:\n\tstack<int> st = {};\n\tint numMin, numTemp;\n};\n")])])]),e("p",{attrs:{id:"用队列实现栈"}}),t._v(" "),e("h3",{attrs:{id:"_225-用队列实现栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_225-用队列实现栈"}},[t._v("#")]),t._v(" 225. 用队列实现栈")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/implement-stack-using-queues/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("使用队列实现栈的下列操作：")]),t._v(" "),e("p",[t._v("push(x) -- 元素 x 入栈\npop() -- 移除栈顶元素\ntop() -- 获取栈顶元素\nempty() -- 返回栈是否为空\n注意:")]),t._v(" "),e("p",[t._v("你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。\n你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。")]),t._v(" "),e("h4",{attrs:{id:"第一版-不难"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-不难"}},[t._v("#")]),t._v(" 第一版，不难")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 C++ 提交中击败了73.27%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :9 MB, 在所有 C++ 提交中击败了23.13%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class MyStack {\npublic:\n\t/** Initialize your data structure here. */\n\tMyStack() {\n\n\t}\n\n\t/** Push element x onto stack. */\n\tvoid push(int x) {\n\t\tin.push(x);\n\t}\n\n\t/** Removes the element on top of the stack and returns that element. */\n\tint pop() {\n\t\twhile (in.size()>1) {\n\t\t\tout.push(in.front());\n\t\t\tin.pop();\n\t\t}\n        int i=in.front();\n\t\tin.pop();\n\n\t\twhile (!out.empty())\n\t\t{\n\t\t\tin.push(out.front());\n\t\t\tout.pop();\n\t\t}\n        return i;\n\n\t}\n\n\t/** Get the top element. */\n\tint top() {\n\t\treturn in.back();\n\t}\n\n\t/** Returns whether the stack is empty. */\n\tbool empty() {\n\t\treturn in.empty() && out.empty();\n\n\t}\n\nprivate:\n\tqueue<int> in;\n\tqueue<int> out;\n};\n")])])]),e("p",{attrs:{id:"棒球比赛"}}),t._v(" "),e("h3",{attrs:{id:"_682-棒球比赛"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_682-棒球比赛"}},[t._v("#")]),t._v(" 682. 棒球比赛")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/baseball-game/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("你现在是棒球比赛记录员。\n给定一个字符串列表，每个字符串可以是以下四种类型之一：\n1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v('"+"（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。')]),t._v(" "),e("li",[t._v('"D"（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。')]),t._v(" "),e("li",[t._v('"C"（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。')])]),t._v(" "),e("p",[t._v("每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。\n你需要返回你在所有回合中得分的总和。")]),t._v(" "),e("p",[t._v("示例 1:")]),t._v(" "),e("p",[t._v('输入: ["5","2","C","D","+"]\n输出: 30\n解释:\n第1轮：你可以得到5分。总和是：5。\n第2轮：你可以得到2分。总和是：7。\n操作1：第2轮的数据无效。总和是：5。\n第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。\n第4轮：你可以得到5 + 10 = 15分。总数是：30。\n示例 2:')]),t._v(" "),e("p",[t._v('输入: ["5","-2","4","C","D","9","+","+"]\n输出: 27\n解释:\n第1轮：你可以得到5分。总和是：5。\n第2轮：你可以得到-2分。总数是：3。\n第3轮：你可以得到4分。总和是：7。\n操作1：第3轮的数据无效。总数是：3。\n第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。\n第5轮：你可以得到9分。总数是：8。\n第6轮：你可以得到-4 + 9 = 5分。总数是13。\n第7轮：你可以得到9 + 5 = 14分。总数是27。\n注意：')]),t._v(" "),e("p",[t._v("输入列表的大小将介于1和1000之间。\n列表中的每个整数都将介于-30000和30000之间。")]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的"}},[t._v("#")]),t._v(" 第一版 自己写的")]),t._v(" "),e("p",[t._v("执行用时 :8 ms, 在所有 cpp 提交中击败了83.02%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :9.3 MB, 在所有 cpp 提交中击败了85.61%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('int calPoints(vector<string>& ops) {\n    stack<int> score;\n\tint doubleScore,temp;\n\tfor (auto it = ops.begin(); it != ops.end(); ++it) {\n\n\t\tif (*it == "C" && !score.empty()) {\n\t\t\tscore.pop();\n\t\t}\n\n\t\telse if (*it == "D" && !score.empty()) { \n\t\t\tscore.push(score.top()*2); }\n\t\telse if (*it == "+") {\n\t\t\tdoubleScore = score.top();\n\t\t\tscore.pop();\n\t\t\ttemp = score.top();\n\t\t\tscore.push(doubleScore);\n\t\t\tscore.push(doubleScore + temp);\n\t\t}\n\t\telse {\n\t\t\tdoubleScore = 0;\n\t\t\ttemp = 1;\n\t\t\tfor (auto a : *it) {\n\t\t\t\tif(a==\'-\') temp = -1; //注意负数的情况\n\t\t\t\telse\n\t\t\t\t\tdoubleScore = doubleScore * 10 + a - \'0\';\n\t\t\t\t\n\t\t\t}\n\t\t\tscore.push(doubleScore*temp);\n\t\t}\n\n\t}\n\tdoubleScore = 0;\n\twhile (!score.empty()) {\n\t\tdoubleScore += score.top();\n\t\tscore.pop();\n\t}\n\n\treturn doubleScore;\n        \n    }\n')])])]),e("p",{attrs:{id:"比较含退格的字符串"}}),t._v(" "),e("h3",{attrs:{id:"_844-比较含退格的字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_844-比较含退格的字符串"}},[t._v("#")]),t._v(" 844. 比较含退格的字符串")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/backspace-string-compare/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。")]),t._v(" "),e("p",[t._v("示例 1：")]),t._v(" "),e("p",[t._v('输入：S = "ab#c", T = "ad#c"\n输出：true\n解释：S 和 T 都会变成 “ac”。\n示例 2：')]),t._v(" "),e("p",[t._v('输入：S = "ab##", T = "c#d#"\n输出：true\n解释：S 和 T 都会变成 “”。\n示例 3：')]),t._v(" "),e("p",[t._v('输入：S = "a##c", T = "#a#c"\n输出：true\n解释：S 和 T 都会变成 “c”。\n示例 4：')]),t._v(" "),e("p",[t._v('输入：S = "a#c", T = "b"\n输出：false\n解释：S 会变成 “c”，但 T 仍然是 “b”。')]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("1 <= S.length <= 200\n1 <= T.length <= 200\nS 和 T 只含有小写字母以及字符 '#'。")]),t._v(" "),e("p",[t._v("第一版，学1047题的string作为栈的方法")]),t._v(" "),e("p",[t._v("执行用时 :4 ms, 在所有 C++ 提交中击败了83.55%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.5 MB, 在所有 C++ 提交中击败了82.47%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("bool backspaceCompare(string S, string T) {\n\tstring sTemp = \"\", tTemp = \"\";\n\tfor (auto s : S) {\n\t\tif (s == '#') {\n\t\t\tif (sTemp.size()>0)//注意判断条件\n\t\t\t\tsTemp.pop_back();\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\tsTemp += s;\n\t}\n\tfor (auto t : T) {\n\t\tif (t == '#') {\n\t\t\tif (tTemp.size()>0)\n\t\t\t\ttTemp.pop_back();\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\ttTemp += t;\n\t}\n\treturn sTemp == tTemp;\n}\n")])])]),e("p",{attrs:{id:"删除字符串中的所有相邻重复项"}}),t._v(" "),e("h3",{attrs:{id:"_1047-删除字符串中的所有相邻重复项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1047-删除字符串中的所有相邻重复项"}},[t._v("#")]),t._v(" 1047. 删除字符串中的所有相邻重复项")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。")]),t._v(" "),e("p",[t._v("在 S 上反复执行重复项删除操作，直到无法继续删除。")]),t._v(" "),e("p",[t._v("在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。")]),t._v(" "),e("p",[t._v("示例：")]),t._v(" "),e("p",[t._v('输入："abbaca"\n输出："ca"\n解释：\n例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。')]),t._v(" "),e("p",[t._v("提示：")]),t._v(" "),e("p",[t._v("1 <= S.length <= 20000\nS 仅由小写英文字母组成。")]),t._v(" "),e("h4",{attrs:{id:"第一版-自己写的-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-自己写的-2"}},[t._v("#")]),t._v(" 第一版，自己写的")]),t._v(" "),e("p",[t._v("执行用时 :32 ms, 在所有 C++ 提交中击败了63.22%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :12.1 MB, 在所有 C++ 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('string removeDuplicates(string S) {\n\tif (S.size() <= 1) return S;\n\tstack<char> result;\n\tfor (auto a : S) {\n\t\tif (result.empty()) {\n\t\t\tresult.push(a);\n\t\t}\n\t\telse{\n\t\t\tif (a == result.top())\n\t\t\t\tresult.pop();\n\t\t\telse\n\t\t\t\tresult.push(a);\n\t\t}\n\t}\n\tS = "";\n\twhile (!result.empty()) {\n\t\tS += result.top();\n\t\tresult.pop();\n\t}\n\treverse(S.begin(), S.end());//注意要反转才是正确结果\n\treturn S;\n\n}\n')])])]),e("h4",{attrs:{id:"第二版-使用另一个string作为一个栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-使用另一个string作为一个栈"}},[t._v("#")]),t._v(" 第二版，使用另一个string作为一个栈")]),t._v(" "),e("p",[t._v("执行用时 :12 ms, 在所有 C++ 提交中击败了99.59%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :12.4 MB, 在所有 C++ 提交中击败了100.00%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('string removeDuplicates(string S) {\n\t string res = "";\n        for(char c: S)\n            if(res.size() && res.back() == c)\n                res.pop_back();\n            else\n                res += c;\n        return res;\n}\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);