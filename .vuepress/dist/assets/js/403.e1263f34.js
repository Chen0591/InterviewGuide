(window.webpackJsonp=window.webpackJsonp||[]).push([[403],{818:function(t,n,e){"use strict";e.r(n);var i=e(62),s=Object(i.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",{attrs:{id:"两数相除"}}),t._v(" "),e("h3",{attrs:{id:"_29-两数相除-没想明白"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_29-两数相除-没想明白"}},[t._v("#")]),t._v(" 29. 两数相除   没想明白")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/divide-two-integers/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。")]),t._v(" "),e("p",[t._v("返回被除数 dividend 除以除数 divisor 得到的商。")]),t._v(" "),e("p",[t._v("示例 1:")]),t._v(" "),e("p",[t._v("输入: dividend = 10, divisor = 3\n输出: 3\n示例 2:")]),t._v(" "),e("p",[t._v("输入: dividend = 7, divisor = -3\n输出: -2\n说明:")]),t._v(" "),e("p",[t._v("被除数和除数均为 32 位有符号整数。\n除数不为 0。\n假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。")]),t._v(" "),e("p",[t._v("第一版 个人版本，超时了")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int divide(int dividend, int divisor) {//被除数和除数都是整数，且结果不能溢出\n\tif (dividend == INT_MIN && divisor == -1) return INT_MAX;\n\tif (dividend == 0) return 0;\n\tint signal = -1;\n\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))  signal = 1;\n\tif (signal == 1)\n\t{\n\t\tsignal = 0;\n\t\tif (dividend > 0)\n\t\t{\n\t\t\twhile (dividend >= 0 && signal<=INT_MAX) {\n\t\t\t\tdividend -= divisor;\n\t\t\t\tsignal += 1;\n\t\t\t}\t\t\n\t\t}\n\t\telse {\n\t\t\twhile (dividend <= 0 && signal <= INT_MAX) {\n\t\t\t\tdividend -= divisor;\n\t\t\t\tsignal += 1;\n\t\t\t}\n\t\t}\n\t\treturn signal==\tINT_MAX?INT_MAX:signal-1;\n\t}\n\telse\n\t{\n\t\tsignal = 0;\n\t\tif (dividend > 0)\n\t\t{\n\t\t\twhile (dividend >= 0 && signal>=INT_MIN) {\n\t\t\t\tdividend += divisor;\n\t\t\t\tsignal -= 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (dividend <= 0 && signal >= INT_MIN) {\n\t\t\t\tdividend += divisor;\n\t\t\t\tsignal -= 1;\n\t\t\t}\n\t\t}\n\t\treturn signal == INT_MIN ? INT_MIN : signal + 1;\n\t}\n}\n")])])]),e("p",{attrs:{id:"在排序数组中查找元素的第一个和最后一个位置"}}),t._v(" "),e("h3",{attrs:{id:"_34-在排序数组中查找元素的第一个和最后一个位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_34-在排序数组中查找元素的第一个和最后一个位置"}},[t._v("#")]),t._v(" 34. 在排序数组中查找元素的第一个和最后一个位置")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("h4",{attrs:{id:"第一版"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版"}},[t._v("#")]),t._v(" 第一版")]),t._v(" "),e("p",[t._v("最后执行的输入为")]),t._v(" "),e("p",[e("strong",[t._v("[1,2,2]\n2")])]),t._v(" "),e("p",[t._v("返回的错误为："),e("strong",[t._v("AddressSanitizer: heap-buffer-overflow on address 0x60200000053c at pc 0x0000004066e1 bp")])]),t._v(" "),e("p",[t._v("这是数组越界的错误")]),t._v(" "),e("p",[t._v("左看右看也没找到越界在哪里")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<int> searchRange(vector<int>& nums, int target) {\n    if (nums.empty() || nums[0] > target || nums[nums.size() - 1] < target) return vector<int>{-1, -1};//当nums为空或者最小值也大于target或者最大值依然//小于target，直接返回\n\t\n\tint minIndex,maxIndex,mid, low = 0, high = nums.size() - 1;\n\twhile (low + 1 < high) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (nums[mid] == target) //找到目标做处理\n\t\t{\n\t\t\twhile (nums[mid] == target)\n\t\t\t{\n\t\t\t\tmid--;\n\t\t\t}\n\t\t\tminIndex = mid + 1;\n\t\t\tmid++;\n\t\t\twhile (nums[mid] == target)//越界在这里\n\t\t\t{\n\t\t\t\tmid++;\n\t\t\t}\n\t\t\tmaxIndex = mid - 1;\n\t\t\treturn { minIndex,maxIndex };\n\t\t}\n\t\telse if (nums[mid] > target) {\n\t\t\thigh = mid;\n\t\t}\n\t\telse { low = mid; }\n\t}\n\n\tif (nums[low] == target) {\n\t\tif (nums[high] == target)  return { low,high };\n\t\telse\n\t\t\treturn { low,low };\n\t}\n\telse if (nums[high] == target) {\n\t\treturn { high,high };\n\t}\n\telse\n\t\treturn { -1,-1 };   \n    }\n")])])]),e("p",[t._v("越界解析 ：nums[2]为最后一个元素，等于target，此时再进入循环，mid++，所以访问nums[3]即为越界，所以判断条件不够，不止上届，同样的下界也应该增加判断条件")]),t._v(" "),e("h4",{attrs:{id:"第二版"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版"}},[t._v("#")]),t._v(" 第二版")]),t._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<int> searchRange(vector<int>& nums, int target) {\nif (nums.empty() || nums[0] > target || nums[nums.size() - 1] < target) return {-1, -1};\n\nint minIndex,maxIndex,mid, low = 0, high = nums.size() - 1;\nwhile (low + 1 < high) {\n\tmid = low + (high - low) / 2;\n\tif (nums[mid] == target)\n\t{\n\t\twhile (mid>=0 && nums[mid] == target)//这里增加界限判断，不至于越界访问\n\t\t{\n\n\t\t\tmid--;\n\t\t}\n\t\tif (mid < 0) { \n\t\t\tminIndex = 0; mid = 0; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tminIndex = ++mid;\n\t\t}\n\n\t\twhile (mid<nums.size() && nums[mid] == target)//这里增加界限判断，不至于越界访问\n\t\t{\n\t\t\tmid++;\n\t\t}\n\t\tif (mid == nums.size()) {//虽然此时满足mid==nums.size(),但10并不是target\n\t\t\tmaxIndex = nums.size()-1; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tminIndex = --mid;\n\t\t}\n\n\t\treturn { minIndex,maxIndex };\n\t}\n\telse if (nums[mid] > target) {\n\t\thigh = mid;\n\t}\n\telse { low = mid; }\n}\nif (nums[low] == target) {\n\tif (nums[high] == target)  return { low,high };\n\telse\n\t\treturn { low,low };\n}\nelse if (nums[high] == target) {\n\treturn { high,high };\n}\nelse\n\treturn { -1,-1 };\n}\n")])])]),e("p",[t._v("最后输入为输入："),e("strong",[t._v("[5,7,7,8,8,10]  8")])]),t._v(" "),e("p",[t._v("输出："),e("strong",[t._v("[3,5]")])]),t._v(" "),e("p",[t._v("预期："),e("strong",[t._v("[3,4]")])]),t._v(" "),e("p",[t._v("此时跟上面又有不同，这里10为末尾元素，也不是目标，10的前面一个是目标元素，虽然此时mid=nums.size(),，但是mid=nums.size()-1=5，还是指的是10，所以如果最后到了数组末尾，还需要再加判断")]),t._v(" "),e("h4",{attrs:{id:"第三版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三版本"}},[t._v("#")]),t._v(" 第三版本")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<int> searchRange(vector<int>& nums, int target) {\nif (nums.empty() || nums[0] > target || nums[nums.size() - 1] < target) \n\treturn { -1, -1 };//当nums为空或者最小值也大于target或者最大值依然小于target，直接返回\n\nint minIndex, maxIndex, mid, low = 0, high = nums.size() - 1;\nwhile (low + 1 < high) {//在数组内部查找\n\tmid = low + (high - low) / 2;\n\tif (nums[mid] == target)//招到了target\n\t{\n\t\tint tempMid = mid;//双份mid更方便一些,一份查找左边界，一份查找有边界\n\t\twhile (mid >= 0 && nums[mid] == target)//左侧查找边界\n\t\t{\n\t\t\tmid--;\n\t\t}\n\t\tif (mid < 0) { //到了数组头了，还需要再加判断头元素是不是target\n\t\t\tif (nums[0] == target) minIndex = 0;\n\t\t\telse\n\t\t\t\tminIndex = mid + 2;\n\t\t}\n\t\telse //没到数组头，说明头元素不是target\n\t\t\tminIndex = ++mid;\n\n\t\twhile (tempMid <= nums.size() - 1 && nums[tempMid] == target)//右侧查找边界\n\t\t{\n\t\t\ttempMid++;\n\t\t}\n\t\tif (tempMid == nums.size()) {//到了数组尾部了，还需要再加判断尾部元素是不是target\n\t\t\tif (nums[nums.size() - 1] == target) maxIndex = nums.size() - 1;\n\t\t\telse\n\t\t\t\tmaxIndex = nums.size() - 2;\n\t\t}\n\t\telse//没到数组尾部，说明尾部元素不是target\n\t\t\tmaxIndex = --tempMid;\n\t\treturn { minIndex,maxIndex };\n\t}\n\telse if (nums[mid] > target) {\n\t\thigh = mid;\n\t}\n\telse { low = mid; }\n}\n\nif (nums[low] == target) {//没在数组除了low和high的位置找到target，再处理\n\tif (nums[high] == target)  return { low,high };\n\telse\n\t\treturn { low,low };\n}\nelse if (nums[high] == target) {\n\treturn { high,high };\n}\nelse\n\treturn { -1,-1 };\n}\n\n")])])]),e("p",[t._v("执行用时 :8 ms, 在所有 C++ 提交中击败了95.18%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :10.4 MB, 在所有 C++ 提交中击败了76.75%的用户")]),t._v(" "),e("p",{attrs:{id:"寻找旋转排序数组中的最小值"}}),t._v(" "),e("h3",{attrs:{id:"_153-寻找旋转排序数组中的最小值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_153-寻找旋转排序数组中的最小值"}},[t._v("#")]),t._v(" 153. 寻找旋转排序数组中的最小值")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("假设按照升序排序的数组在预先未知的某个点上进行了旋转。"),e("strong",[t._v("没有想象中的难")])]),t._v(" "),e("p",[t._v("( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。")]),t._v(" "),e("p",[t._v("请找出其中最小的元素。")]),t._v(" "),e("p",[t._v("你可以假设数组中不存在重复元素。")]),t._v(" "),e("p",[t._v("示例 1:")]),t._v(" "),e("p",[t._v("输入: [3,4,5,1,2]\n输出: 1\n示例 2:")]),t._v(" "),e("p",[t._v("输入: [4,5,6,7,0,1,2]\n输出: 0")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int findMin(vector<int>& nums) {\n\tif (nums.size() == 1 || nums[0]<nums[nums.size()-1]) return nums[0];\n\tint high = nums.size() - 1;\n\twhile(nums[high]< nums[0])\n\t{\n\t\thigh--;\n\t}\n\t++high;\n\treturn nums[high];\n\n}\n")])])]),e("p",{attrs:{id:"寻找峰值"}}),t._v(" "),e("h3",{attrs:{id:"_162-寻找峰值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_162-寻找峰值"}},[t._v("#")]),t._v(" 162. 寻找峰值")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/find-peak-element/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("峰值元素是指其值大于左右相邻值的元素。")]),t._v(" "),e("p",[t._v("给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。")]),t._v(" "),e("p",[t._v("数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。")]),t._v(" "),e("p",[t._v("你可以假设 nums[-1] = nums[n] = -∞。")]),t._v(" "),e("p",[t._v("示例 1:")]),t._v(" "),e("p",[t._v("输入: nums = [1,2,3,1]\n输出: 2\n解释: 3 是峰值元素，你的函数应该返回其索引 2。\n示例 2:")]),t._v(" "),e("p",[t._v("输入: nums = [1,2,1,3,5,6,4]\n输出: 1 或 5\n解释: 你的函数可以返回索引 1，其峰值元素为 2；\n或者返回索引 5， 其峰值元素为 6。")]),t._v(" "),e("h4",{attrs:{id:"第一版-直接暴力法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-直接暴力法"}},[t._v("#")]),t._v(" 第一版，直接暴力法")]),t._v(" "),e("p",[t._v("执行用时 :8 ms, 在所有 C++ 提交中击败了73.77%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :8.7 MB, 在所有 C++ 提交中击败了69.45%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    int findPeakElement(vector<int>& nums) {\n    if (nums.size() <= 1) return 0;\n\tif (nums[1] < nums[0]) return 0;\n\tif (nums[nums.size() - 2] < nums[nums.size() - 1]) return nums.size() - 1;\n\tint temp = 0;\n\tfor (int i = 1; i <= nums.size() - 2;++i) {\n\t\tif(nums[i]> nums[i-1] &&  nums[i]>nums[i + 1]) return i;\n\n\t}\n    return 0;\n\t}\n")])])]),e("h4",{attrs:{id:"第二版-二分法模板"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-二分法模板"}},[t._v("#")]),t._v(" 第二版 二分法模板")]),t._v(" "),e("p",[e("strong",[t._v("low<=high")])]),t._v(" "),e("p",[e("strong",[t._v("low=mid+1;")])]),t._v(" "),e("p",[e("strong",[t._v("high=mid-1;")])]),t._v(" "),e("p",[t._v("结束时，low在high前面一个元素了，差值为0和1时都会继续执行，需要"),e("strong",[t._v("注意")]),t._v("边界问题")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    int findPeakElement(vector<int>& nums) {\n\tif (nums.size() <= 1) return 0;\n\tif (nums[0] > nums[1]) {\n\t\treturn 0;\n\t}\n\tif (nums[nums.size() - 1] > nums[nums.size() - 2]) {\n\t\treturn nums.size() - 1;\n\t}\n\tint l = 0,r = nums.size() - 1;\n\n\twhile (l  <= r) {\n\t\tint m = (l + r) / 2;\n\n\t\tif (m > 0 and nums[m - 1] > nums[m]) {\n\t\t\tr = m-1;\n\t\t}\n\t\telse if (m < nums.size() and nums[m + 1] > nums[m]) {\n\t\t\tl = m+1;\n\t\t}\n\t\telse {\n\t\t\treturn m;\n\t\t}\n\t}\n\n\treturn l;\n\t}\n")])])]),e("p",{attrs:{id:"寻找重复数"}}),t._v(" "),e("h3",{attrs:{id:"_287-寻找重复数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_287-寻找重复数"}},[t._v("#")]),t._v(" 287. 寻找重复数")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/find-the-duplicate-number/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个包含 "),e("em",[t._v("n")]),t._v(" + 1 个整数的数组 "),e("em",[t._v("nums")]),t._v("，其数字都在 1 到 "),e("em",[t._v("n")]),t._v(" 之间（包括 1 和 "),e("em",[t._v("n")]),t._v("），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: [1,3,4,2,2]\n输出: 2\n")])])]),e("p",[e("strong",[t._v("示例 2:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: [3,1,3,4,2]\n输出: 3\n")])])]),e("p",[e("strong",[t._v("说明：")])]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("不能")]),t._v("更改原数组（假设数组是只读的）。")]),t._v(" "),e("li",[t._v("只能使用额外的 "),e("em",[t._v("O")]),t._v("(1) 的空间。")]),t._v(" "),e("li",[t._v("时间复杂度小于 "),e("em",[t._v("O")]),t._v("("),e("em",[t._v("n")]),t._v("2) 。")]),t._v(" "),e("li",[t._v("数组中只有一个重复的数字，但它可能不止重复出现一次。")])]),t._v(" "),e("h4",{attrs:{id:"第一版-这个要求比较麻烦-看的别人的-真的厉害"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-这个要求比较麻烦-看的别人的-真的厉害"}},[t._v("#")]),t._v(" 第一版，这个要求比较麻烦...，看的别人的,真的厉害")]),t._v(" "),e("p",[t._v("https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/")]),t._v(" "),e("p",[t._v("执行用时 :16 ms, 在所有 cpp 提交中击败了62.53%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :10 MB, 在所有 cpp 提交中击败了12.18%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int findDuplicate(vector<int>& nums) {\n\tint len = nums.size();\n\tint left = 0,counter=0;\n\tint right = len - 1;\n\n\twhile (left < right) {\n\t\tint mid = (left + right + 1) >> 1;\n\t\tfor (int &num : nums) {\n\t\t\tif (num < mid) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\n\t\tif (counter >= mid) {\n\t\t\tright = mid - 1;\n\t\t}\n\t\telse {\n\t\t\tleft = mid;\n\t\t}\n\t}\n\treturn left;\n\n\n}\n")])])]),e("h4",{attrs:{id:"第二版-其实也是别人的法子-真的长见识了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-其实也是别人的法子-真的长见识了"}},[t._v("#")]),t._v(" 第二版，其实也是别人的法子，真的长见识了")]),t._v(" "),e("p",[t._v("(C++)二分法，主要原因是题目给出所有数都是1 - n，二分查找时的Mid就用来探测比Mid小的数有多少个。。。")]),t._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Solution\n{\npublic:\n    int findDuplicate(vector<int>& nums)\n    {\n        int low = 0, high = nums.size() - 1;\n        while(low < high)\n        {\n            int mid = low + ((high - low) >> 2);\n            int count = 0;\n            for(int num : nums)\n                if(num <= mid) count++;\n            if(count <= mid) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n};\n")])])]),e("p",{attrs:{id:"有序矩阵中第小的元素"}}),t._v(" "),e("h3",{attrs:{id:"_378-有序矩阵中第k小的元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_378-有序矩阵中第k小的元素"}},[t._v("#")]),t._v(" 378. 有序矩阵中第K小的元素")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个 "),e("em",[t._v("n x n")]),t._v(" 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。\n"),e("strong",[t._v("请注意，它是排序后的第k小元素，而不是第k个元素。")])]),t._v(" "),e("p",[e("strong",[t._v("示例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("matrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\n返回 13。\n")])])]),e("p",[e("strong",[t._v("说明:")]),t._v("\n你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。")]),t._v(" "),e("h4",{attrs:{id:"第一版-优先队列做一次-用大顶堆求top小"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-优先队列做一次-用大顶堆求top小"}},[t._v("#")]),t._v(" 第一版，优先队列做一次，用大顶堆求top小")]),t._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" int kthSmallest(vector<vector<int>>& matrix, int k) {\n    priority_queue<int,vector<int>,less<int>> result;\n\tint len = matrix[0].size();\n\tint count = 0;\n\tfor (unsigned i = 0; i < len; ++i) {\n\t\tfor (unsigned j = 0; j < len; ++j) {\n\t\tif (result.size() >= k) {\n            if(result.top()>matrix[i][j]){\n\t\t\tresult.push(matrix[i][j]);\n\t\t\tresult.pop();\n            }\n\t\t}\n\t\telse\n\t\t\tresult.push(matrix[i][j]);\n\t\t\t\t}\n}\n\nreturn result.top();\n    \n}\n")])])]),e("p",[t._v("执行用时 :48 ms, 在所有 cpp 提交中击败了67.71%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :13.1 MB, 在所有 cpp 提交中击败了34.15%的用户")]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("h4",{attrs:{id:"第二版-二分查找-这种法子也可以-但是我不太会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-二分查找-这种法子也可以-但是我不太会"}},[t._v("#")]),t._v(" 第二版，二分查找 这种法子也可以，但是我不太会...")]),t._v(" "),e("p",{attrs:{id:"寻找右区间"}}),t._v(" "),e("h3",{attrs:{id:"_436-寻找右区间-很好的题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_436-寻找右区间-很好的题"}},[t._v("#")]),t._v(" 436. 寻找右区间,很好的题")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/find-right-interval/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("执行用时 :124 ms, 在所有 C++ 提交中击败了93.67%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :26.4 MB, 在所有 C++ 提交中击败了5.88%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vector<int> findRightInterval(vector<vector<int>>& intervals) {\n\t\n\tif (intervals.size() <= 1) return {-1};\n\tvector<int> result;\n\tmap<int, int>record;//需要用到lower_bound，不能用unordered_map\n\tresult.reserve(intervals.size());\n\tfor (int i = 0; i < intervals.size(); ++i) {\n\t\trecord[intervals[i][0]] = i;//保存区间头和整体区间所在位序\n\t}\n\n\tint pos;\n\tfor (auto a : intervals) {\n\t\tauto it = record.lower_bound(a[1]);//查找不小于区间尾的record中元素的最小位置\n\t\tif (it != record.end())\n\t\t{\n\t\t\tresult.push_back(it->second); //找到了，保存该区间所在位序\n\t\t}\n\t\telse\n\t\t\tresult.push_back(-1); //没找到就-1\n\t}\n\treturn result;\n\n}\n")])])]),e("p",{attrs:{id:"四数相加"}}),t._v(" "),e("h3",{attrs:{id:"_454-四数相加-ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_454-四数相加-ii"}},[t._v("#")]),t._v(" 454. 四数相加 II")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/4sum-ii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。")]),t._v(" "),e("p",[t._v("为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。")]),t._v(" "),e("p",[t._v("例如:")]),t._v(" "),e("p",[t._v("输入:\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]")]),t._v(" "),e("p",[t._v("输出:\n2")]),t._v(" "),e("p",[t._v("解释:\n两个元组如下:")]),t._v(" "),e("ol",[e("li",[t._v("(0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0")]),t._v(" "),e("li",[t._v("(1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0")])]),t._v(" "),e("p",[t._v("思路：建立一个哈希映射，一个记录AB数组的组合和，和为key，出现的次数为value\n计算CD数组的组合和，得到相反数，若该数存在于key中，即符合要求，将答案加上AB组合和中该数出现的次数(value)")]),t._v(" "),e("h4",{attrs:{id:"第一版-使用map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-使用map"}},[t._v("#")]),t._v(" 第一版，使用map")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\n\n    int num = 0,temp=0;\n\tmap<int, int>  sum_map;\n\tfor (auto a : A) {\n\t\tfor (auto b : B) {\n\t\t\tif (sum_map.count(a + b) == 0) sum_map[a + b] = 1;\n\t\t\telse\n\t\t\t\t++sum_map[a + b];\n\t\t}\n\t}\n\n\tfor (auto c : C) {\n\t\tfor (auto d : D) {\n\t\t\ttemp = -(c + d);\n\t\t\tif (sum_map.count(temp)) num+=sum_map[temp];\n\t\t}\n\t}\n\n\treturn num;  \n    }\n")])])]),e("p",[t._v("执行用时 :492 ms, 在所有 C++ 提交中击败了42.54%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :29.3 MB, 在所有 C++ 提交中击败了57.21%的用户")]),t._v(" "),e("h4",{attrs:{id:"第二版-unordered-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-unordered-map"}},[t._v("#")]),t._v(" 第二版 ，unordered_map")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int num = 0,temp=0;\n\tunordered_map<int, int>  sum_map;\n\tfor (auto a : A) {\n\t\tfor (auto b : B) {\n\t\t\tif (sum_map.count(a + b) == 0) sum_map[a + b] = 1;\n\t\t\telse\n\t\t\t\t++sum_map[a + b];\n\t\t}\n\t}\n\n\tfor (auto c : C) {\n\t\tfor (auto d : D) {\n\t\t\ttemp = -(c + d);\n\t\t\tif (sum_map.count(temp)) num+=sum_map[temp];\n\t\t}\n\t}\n\n\treturn num;\n")])])]),e("p",[t._v("执行用时 :1822 ms, 在所有 C++ 提交中击败了98.56%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :28.4 MB, 在所有 C++ 提交中击败了57.21%的用户")]),t._v(" "),e("p",{attrs:{id:"匹配子序列的单词数"}}),t._v(" "),e("h3",{attrs:{id:"_792-匹配子序列的单词数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_792-匹配子序列的单词数"}},[t._v("#")]),t._v(" 792. 匹配子序列的单词数")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/number-of-matching-subsequences/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣原题链接（点我直达）"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定字符串 "),e("code",[t._v("S")]),t._v(" 和单词字典 "),e("code",[t._v("words")]),t._v(", 求 "),e("code",[t._v("words[i]")]),t._v(" 中是 "),e("code",[t._v("S")]),t._v(" 的子序列的单词个数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('示例:\n输入: \nS = "abcde"\nwords = ["a", "bb", "acd", "ace"]\n输出: 3\n解释: 有三个是 S 的子序列的单词: "a", "acd", "ace"。\n')])])]),e("p",[e("strong",[t._v("注意:")])]),t._v(" "),e("ul",[e("li",[t._v("所有在"),e("code",[t._v("words")]),t._v("和 "),e("code",[t._v("S")]),t._v(" 里的单词都只由小写字母组成。")]),t._v(" "),e("li",[e("code",[t._v("S")]),t._v(" 的长度在 "),e("code",[t._v("[1, 50000]")]),t._v("。")]),t._v(" "),e("li",[e("code",[t._v("words")]),t._v(" 的长度在 "),e("code",[t._v("[1, 5000]")]),t._v("。")]),t._v(" "),e("li",[e("code",[t._v("words[i]")]),t._v("的长度在"),e("code",[t._v("[1, 50]")]),t._v("。")])]),t._v(" "),e("h4",{attrs:{id:"第一版-emmmm-自己写的-很差"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一版-emmmm-自己写的-很差"}},[t._v("#")]),t._v(" 第一版 emmmm...自己写的，很差")]),t._v(" "),e("p",[t._v("执行用时 :1136 ms, 在所有 cpp 提交中击败了5.05%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :136 MB, 在所有 cpp 提交中击败了18.75%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int numMatchingSubseq(string S, vector<string>& words) {\n\n\tunordered_map<char, set<int>> mp;\n\tfor (unsigned i = 0; i < S.size(); ++i) {\n\t\tmp[S[i]].insert(i);\n\t}\n\n\tint count = 0,temp;\n\tunsigned i = 0;\n\tfor (auto& word : words) {\n\t\ttemp = *(mp[word[0]].begin());\t\t\n\t\tfor (i = 1; i < word.size(); ++i) {\n\t\t\tauto pos = mp[word[i]].upper_bound(temp);\n\t\t\tif (pos != mp[word[i]].end()) {\n\n\t\t\t\tif (*pos > temp) temp = *pos;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif (i == word.size()) count++;\n\n\t}\n\treturn count;\n\n}\n")])])]),e("h4",{attrs:{id:"第二版-稍微改进一下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二版-稍微改进一下"}},[t._v("#")]),t._v(" 第二版，稍微改进一下")]),t._v(" "),e("p",[t._v("执行用时 :308 ms, 在所有 cpp 提交中击败了58.08%的用户")]),t._v(" "),e("p",[t._v("内存消耗 :40.5 MB, 在所有 cpp 提交中击败了65.63%的用户")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int numMatchingSubseq(string S, vector<string>& words) {\n\t\n\n\tunordered_map<char, vector<int>> mp;\n\tfor (unsigned i = 0; i < S.size(); ++i) {\n\t\tmp[S[i]].push_back(i);\n\t}\n\n\tint count = 0,temp;\n\tunsigned i;\n\tfor (auto& word : words) {\n\t\tif (mp.find(word[0]) == mp.end()) //时刻注意判断问题\n\t\t\tcontinue;\n\t\ttemp = *(mp[word[0]].begin());\n\t\tfor (i = 1; i < word.size(); ++i) {\n\t\t\tif (mp.find(word[i]) == mp.end()) //时刻注意判断有无问题\n\t\t\t\tbreak;\n\t\t\tauto pos = upper_bound(mp[word[i]].begin(), mp[word[i]].end(),temp);\n\t\t\tif (pos != mp[word[i]].end()) {\n\t\t\t\ttemp = *pos;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i==word.size()) count++;\n\t}\n\treturn count;\n\n}\n\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);